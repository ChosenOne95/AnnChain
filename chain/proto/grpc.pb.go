// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chain/proto/grpc.proto

package proto

import (
	context "context"
	fmt "fmt"
	rpc "github.com/dappledger/AnnChain/gemmill/protos/rpc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EmptyRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyRequest) Reset()         { *m = EmptyRequest{} }
func (m *EmptyRequest) String() string { return proto.CompactTextString(m) }
func (*EmptyRequest) ProtoMessage()    {}
func (*EmptyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{0}
}
func (m *EmptyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyRequest.Merge(m, src)
}
func (m *EmptyRequest) XXX_Size() int {
	return m.Size()
}
func (m *EmptyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyRequest proto.InternalMessageInfo

func (*EmptyRequest) XXX_MessageName() string {
	return "grpc.EmptyRequest"
}

type CmdChainID struct {
	ChainID              string   `protobuf:"bytes,1,opt,name=ChainID,proto3" json:"ChainID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdChainID) Reset()         { *m = CmdChainID{} }
func (m *CmdChainID) String() string { return proto.CompactTextString(m) }
func (*CmdChainID) ProtoMessage()    {}
func (*CmdChainID) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{1}
}
func (m *CmdChainID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdChainID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdChainID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdChainID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdChainID.Merge(m, src)
}
func (m *CmdChainID) XXX_Size() int {
	return m.Size()
}
func (m *CmdChainID) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdChainID.DiscardUnknown(m)
}

var xxx_messageInfo_CmdChainID proto.InternalMessageInfo

func (m *CmdChainID) GetChainID() string {
	if m != nil {
		return m.ChainID
	}
	return ""
}

func (*CmdChainID) XXX_MessageName() string {
	return "grpc.CmdChainID"
}

type CmdRequestSpecialOP struct {
	ChainID              string   `protobuf:"bytes,1,opt,name=ChainID,proto3" json:"ChainID,omitempty"`
	Tx                   []byte   `protobuf:"bytes,2,opt,name=Tx,proto3" json:"Tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdRequestSpecialOP) Reset()         { *m = CmdRequestSpecialOP{} }
func (m *CmdRequestSpecialOP) String() string { return proto.CompactTextString(m) }
func (*CmdRequestSpecialOP) ProtoMessage()    {}
func (*CmdRequestSpecialOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{2}
}
func (m *CmdRequestSpecialOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdRequestSpecialOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdRequestSpecialOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdRequestSpecialOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdRequestSpecialOP.Merge(m, src)
}
func (m *CmdRequestSpecialOP) XXX_Size() int {
	return m.Size()
}
func (m *CmdRequestSpecialOP) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdRequestSpecialOP.DiscardUnknown(m)
}

var xxx_messageInfo_CmdRequestSpecialOP proto.InternalMessageInfo

func (m *CmdRequestSpecialOP) GetChainID() string {
	if m != nil {
		return m.ChainID
	}
	return ""
}

func (m *CmdRequestSpecialOP) GetTx() []byte {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (*CmdRequestSpecialOP) XXX_MessageName() string {
	return "grpc.CmdRequestSpecialOP"
}

type CmdBlockchainInfo struct {
	MinHeight            int64    `protobuf:"varint,1,opt,name=MinHeight,proto3" json:"MinHeight,omitempty"`
	MaxHeight            int64    `protobuf:"varint,2,opt,name=MaxHeight,proto3" json:"MaxHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdBlockchainInfo) Reset()         { *m = CmdBlockchainInfo{} }
func (m *CmdBlockchainInfo) String() string { return proto.CompactTextString(m) }
func (*CmdBlockchainInfo) ProtoMessage()    {}
func (*CmdBlockchainInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{3}
}
func (m *CmdBlockchainInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdBlockchainInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdBlockchainInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdBlockchainInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdBlockchainInfo.Merge(m, src)
}
func (m *CmdBlockchainInfo) XXX_Size() int {
	return m.Size()
}
func (m *CmdBlockchainInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdBlockchainInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CmdBlockchainInfo proto.InternalMessageInfo

func (m *CmdBlockchainInfo) GetMinHeight() int64 {
	if m != nil {
		return m.MinHeight
	}
	return 0
}

func (m *CmdBlockchainInfo) GetMaxHeight() int64 {
	if m != nil {
		return m.MaxHeight
	}
	return 0
}

func (*CmdBlockchainInfo) XXX_MessageName() string {
	return "grpc.CmdBlockchainInfo"
}

type CmdBlock struct {
	Height               int64    `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdBlock) Reset()         { *m = CmdBlock{} }
func (m *CmdBlock) String() string { return proto.CompactTextString(m) }
func (*CmdBlock) ProtoMessage()    {}
func (*CmdBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{4}
}
func (m *CmdBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdBlock.Merge(m, src)
}
func (m *CmdBlock) XXX_Size() int {
	return m.Size()
}
func (m *CmdBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdBlock.DiscardUnknown(m)
}

var xxx_messageInfo_CmdBlock proto.InternalMessageInfo

func (m *CmdBlock) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (*CmdBlock) XXX_MessageName() string {
	return "grpc.CmdBlock"
}

type CmdBroadcastTx struct {
	Tx                   []byte   `protobuf:"bytes,1,opt,name=Tx,proto3" json:"Tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdBroadcastTx) Reset()         { *m = CmdBroadcastTx{} }
func (m *CmdBroadcastTx) String() string { return proto.CompactTextString(m) }
func (*CmdBroadcastTx) ProtoMessage()    {}
func (*CmdBroadcastTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{5}
}
func (m *CmdBroadcastTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdBroadcastTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdBroadcastTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdBroadcastTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdBroadcastTx.Merge(m, src)
}
func (m *CmdBroadcastTx) XXX_Size() int {
	return m.Size()
}
func (m *CmdBroadcastTx) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdBroadcastTx.DiscardUnknown(m)
}

var xxx_messageInfo_CmdBroadcastTx proto.InternalMessageInfo

func (m *CmdBroadcastTx) GetTx() []byte {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (*CmdBroadcastTx) XXX_MessageName() string {
	return "grpc.CmdBroadcastTx"
}

type CmdQuery struct {
	Query                []byte   `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdQuery) Reset()         { *m = CmdQuery{} }
func (m *CmdQuery) String() string { return proto.CompactTextString(m) }
func (*CmdQuery) ProtoMessage()    {}
func (*CmdQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{6}
}
func (m *CmdQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdQuery.Merge(m, src)
}
func (m *CmdQuery) XXX_Size() int {
	return m.Size()
}
func (m *CmdQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdQuery.DiscardUnknown(m)
}

var xxx_messageInfo_CmdQuery proto.InternalMessageInfo

func (m *CmdQuery) GetQuery() []byte {
	if m != nil {
		return m.Query
	}
	return nil
}

func (*CmdQuery) XXX_MessageName() string {
	return "grpc.CmdQuery"
}

type CmdEventCode struct {
	CodeHash             []byte   `protobuf:"bytes,1,opt,name=CodeHash,proto3" json:"CodeHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdEventCode) Reset()         { *m = CmdEventCode{} }
func (m *CmdEventCode) String() string { return proto.CompactTextString(m) }
func (*CmdEventCode) ProtoMessage()    {}
func (*CmdEventCode) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{7}
}
func (m *CmdEventCode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdEventCode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdEventCode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdEventCode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdEventCode.Merge(m, src)
}
func (m *CmdEventCode) XXX_Size() int {
	return m.Size()
}
func (m *CmdEventCode) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdEventCode.DiscardUnknown(m)
}

var xxx_messageInfo_CmdEventCode proto.InternalMessageInfo

func (m *CmdEventCode) GetCodeHash() []byte {
	if m != nil {
		return m.CodeHash
	}
	return nil
}

func (*CmdEventCode) XXX_MessageName() string {
	return "grpc.CmdEventCode"
}

type CmdHash struct {
	Hash                 []byte   `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdHash) Reset()         { *m = CmdHash{} }
func (m *CmdHash) String() string { return proto.CompactTextString(m) }
func (*CmdHash) ProtoMessage()    {}
func (*CmdHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9a444f74a3ef6a3, []int{8}
}
func (m *CmdHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CmdHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CmdHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CmdHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdHash.Merge(m, src)
}
func (m *CmdHash) XXX_Size() int {
	return m.Size()
}
func (m *CmdHash) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdHash.DiscardUnknown(m)
}

var xxx_messageInfo_CmdHash proto.InternalMessageInfo

func (m *CmdHash) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (*CmdHash) XXX_MessageName() string {
	return "grpc.CmdHash"
}
func init() {
	proto.RegisterType((*EmptyRequest)(nil), "grpc.EmptyRequest")
	proto.RegisterType((*CmdChainID)(nil), "grpc.CmdChainID")
	proto.RegisterType((*CmdRequestSpecialOP)(nil), "grpc.CmdRequestSpecialOP")
	proto.RegisterType((*CmdBlockchainInfo)(nil), "grpc.CmdBlockchainInfo")
	proto.RegisterType((*CmdBlock)(nil), "grpc.CmdBlock")
	proto.RegisterType((*CmdBroadcastTx)(nil), "grpc.CmdBroadcastTx")
	proto.RegisterType((*CmdQuery)(nil), "grpc.CmdQuery")
	proto.RegisterType((*CmdEventCode)(nil), "grpc.CmdEventCode")
	proto.RegisterType((*CmdHash)(nil), "grpc.CmdHash")
}

func init() { proto.RegisterFile("chain/proto/grpc.proto", fileDescriptor_a9a444f74a3ef6a3) }

var fileDescriptor_a9a444f74a3ef6a3 = []byte{
	// 1065 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x96, 0xcf, 0x76, 0xdb, 0xc4,
	0x17, 0xc7, 0x7f, 0x4a, 0x9b, 0xb8, 0xb9, 0x4d, 0x9c, 0x78, 0xe2, 0xfc, 0x73, 0x1c, 0x37, 0xbf,
	0x01, 0x4a, 0x4f, 0x0e, 0x8d, 0x68, 0xd9, 0xb1, 0x81, 0x44, 0x29, 0x69, 0x21, 0x4d, 0x89, 0xe3,
	0x96, 0x73, 0xba, 0x40, 0x9d, 0x48, 0x13, 0x59, 0x54, 0xa3, 0x51, 0x35, 0x23, 0xe3, 0xb0, 0xe4,
	0x11, 0x60, 0xc3, 0x23, 0xf0, 0x18, 0x2c, 0xbb, 0xe4, 0x1c, 0x5e, 0x80, 0x93, 0xf0, 0x20, 0x9c,
	0x19, 0x49, 0x96, 0x1c, 0x2b, 0x27, 0x0b, 0x56, 0x1a, 0xcd, 0xfd, 0xde, 0xcf, 0x77, 0x34, 0x73,
	0x75, 0x25, 0x58, 0x71, 0xfa, 0xc4, 0x0f, 0xcd, 0x28, 0xe6, 0x92, 0x9b, 0x5e, 0x1c, 0x39, 0x3b,
	0x7a, 0x88, 0x6e, 0xab, 0x71, 0xab, 0xed, 0x51, 0xc6, 0xfc, 0x20, 0x48, 0xe3, 0xc2, 0x8c, 0x23,
	0xc7, 0x1c, 0x69, 0x5a, 0x6d, 0x8f, 0x73, 0x2f, 0xa0, 0x26, 0x89, 0x7c, 0x93, 0x84, 0x21, 0x97,
	0x44, 0xfa, 0x3c, 0x14, 0x59, 0xb4, 0xe9, 0x71, 0x8f, 0x67, 0x5c, 0xee, 0xf1, 0x6c, 0xf6, 0x13,
	0x7d, 0x71, 0x1e, 0x7a, 0x34, 0x7c, 0x28, 0x7e, 0x24, 0x9e, 0x47, 0x63, 0x93, 0x47, 0x3a, 0x6f,
	0x92, 0x81, 0xeb, 0x30, 0xf7, 0x84, 0x45, 0xf2, 0xbc, 0x4b, 0xdf, 0x25, 0x54, 0x48, 0x7c, 0x1f,
	0xc0, 0x62, 0xae, 0xa5, 0x96, 0xfc, 0x6c, 0x1f, 0xad, 0x41, 0x2d, 0x1b, 0xae, 0x19, 0x5b, 0xc6,
	0x83, 0xd9, 0x6e, 0x7e, 0x8b, 0xbf, 0x80, 0x25, 0x8b, 0xb9, 0x59, 0xd6, 0x49, 0x44, 0x1d, 0x9f,
	0x04, 0x2f, 0xbe, 0xbd, 0x3e, 0x01, 0xd5, 0x61, 0xaa, 0x37, 0x5c, 0x9b, 0xda, 0x32, 0x1e, 0xcc,
	0x75, 0xa7, 0x7a, 0x43, 0xfc, 0x02, 0x1a, 0x16, 0x73, 0xf7, 0x02, 0xee, 0xbc, 0xd5, 0x1b, 0xf4,
	0x2c, 0x3c, 0xe3, 0xa8, 0x0d, 0xb3, 0xcf, 0xfd, 0xf0, 0x29, 0xf5, 0xbd, 0xbe, 0xd4, 0x80, 0x5b,
	0xdd, 0x62, 0x42, 0x47, 0xc9, 0x30, 0x8b, 0x4e, 0x65, 0xd1, 0x7c, 0x02, 0x63, 0xb8, 0x93, 0x03,
	0xd1, 0x0a, 0xcc, 0x8c, 0x41, 0xb2, 0x3b, 0xbc, 0x05, 0x75, 0xa5, 0x89, 0x39, 0x71, 0x1d, 0x22,
	0x64, 0x6f, 0x98, 0x2d, 0xcb, 0x18, 0x2d, 0x6b, 0x4b, 0x53, 0x8e, 0x13, 0x1a, 0x9f, 0xa3, 0x26,
	0x4c, 0xeb, 0x41, 0x16, 0x4e, 0x6f, 0xf0, 0x36, 0xcc, 0x59, 0xcc, 0x7d, 0x32, 0xa0, 0xa1, 0xb4,
	0xb8, 0x4b, 0x51, 0x0b, 0xee, 0xa8, 0xeb, 0x53, 0x22, 0xfa, 0x99, 0x70, 0x74, 0x8f, 0x37, 0xa1,
	0x66, 0x31, 0x57, 0x0d, 0x11, 0x82, 0xdb, 0x25, 0x89, 0x1e, 0x3f, 0xfe, 0x7d, 0x01, 0xa0, 0x1b,
	0x39, 0x27, 0x34, 0x1e, 0xf8, 0x0e, 0x45, 0x07, 0x30, 0x73, 0x22, 0x89, 0x4c, 0x04, 0x42, 0x3b,
	0xba, 0x50, 0xca, 0x27, 0xd3, 0x6a, 0xec, 0xa8, 0xa9, 0x2e, 0x15, 0x49, 0x20, 0x53, 0x19, 0x5e,
	0xf9, 0xf9, 0xaf, 0x7f, 0x7e, 0x9d, 0x5a, 0x44, 0x75, 0x5d, 0x20, 0x83, 0x47, 0xa6, 0x48, 0xd3,
	0xbf, 0x86, 0xda, 0x01, 0x0d, 0xa9, 0xf0, 0xab, 0x49, 0xa8, 0x44, 0xca, 0x74, 0x78, 0x55, 0xa3,
	0x1a, 0x68, 0x21, 0x47, 0x79, 0x19, 0x60, 0x5f, 0x6d, 0x25, 0x09, 0x64, 0xbf, 0x12, 0xb5, 0x5c,
	0x42, 0xa5, 0x32, 0x75, 0x8e, 0x78, 0x41, 0xd3, 0x66, 0x51, 0xcd, 0xec, 0xa7, 0xb9, 0x5f, 0xc2,
	0x74, 0x7a, 0x32, 0xf5, 0x14, 0x92, 0x9f, 0x54, 0x6b, 0xb1, 0x04, 0xd0, 0x33, 0x78, 0x59, 0xe7,
	0x2e, 0xa0, 0xf9, 0x7c, 0x25, 0xa7, 0x3a, 0xf1, 0x0d, 0xd4, 0xaf, 0x14, 0xcb, 0xea, 0x38, 0x6a,
	0x14, 0x68, 0xad, 0x5f, 0x65, 0x8e, 0x42, 0xb8, 0xa5, 0xe1, 0x4d, 0x84, 0xc6, 0xe0, 0x3a, 0x8e,
	0x18, 0xa0, 0xfd, 0x84, 0x45, 0x16, 0x0f, 0x05, 0x0d, 0x45, 0x22, 0xd4, 0x26, 0xd3, 0xca, 0xa7,
	0xde, 0x2c, 0x19, 0x4c, 0xa6, 0xe0, 0x0f, 0xb5, 0x49, 0x07, 0xb5, 0x73, 0x13, 0x37, 0x61, 0x91,
	0xed, 0xe4, 0x22, 0x5b, 0x68, 0xf0, 0x1b, 0xa8, 0xbf, 0x0c, 0x1d, 0x1e, 0x9e, 0xf9, 0x31, 0xa3,
	0x6e, 0x6f, 0x58, 0x7d, 0x56, 0xe5, 0x67, 0x19, 0x97, 0xe3, 0x7b, 0xda, 0x66, 0x1d, 0xad, 0xe6,
	0x36, 0x49, 0x11, 0xb7, 0xe5, 0x50, 0x20, 0x0f, 0x1a, 0x47, 0x09, 0xfb, 0x6f, 0x26, 0x1f, 0x68,
	0x93, 0x4d, 0xb4, 0x91, 0x9b, 0x84, 0x09, 0xb3, 0xaf, 0x1a, 0xfd, 0xa0, 0x8d, 0x76, 0x63, 0xa7,
	0xef, 0x0f, 0x68, 0x7a, 0x1a, 0xd5, 0x46, 0xed, 0x92, 0xd1, 0x44, 0x46, 0xb5, 0x17, 0xc9, 0x34,
	0xf6, 0x69, 0x8a, 0x8d, 0x00, 0xbd, 0x0c, 0x05, 0x39, 0xa3, 0x5f, 0x05, 0x89, 0xe8, 0x3f, 0xa7,
	0x2c, 0xe2, 0x3c, 0xb8, 0xf1, 0x94, 0x26, 0x53, 0xf0, 0xc7, 0xda, 0xed, 0xff, 0xb8, 0x5d, 0x6c,
	0x9f, 0xd2, 0xd8, 0x67, 0x4a, 0x64, 0xb3, 0x54, 0xf5, 0xb9, 0xb1, 0x8d, 0x4e, 0xe1, 0x6e, 0xb9,
	0x63, 0x34, 0x8b, 0xb2, 0x2b, 0x66, 0x5b, 0x2b, 0xe5, 0x9a, 0x2b, 0xe6, 0xf1, 0x47, 0xda, 0xe5,
	0x1e, 0x6e, 0x8d, 0x0a, 0x2e, 0x0f, 0xda, 0x72, 0x68, 0x13, 0x71, 0x1e, 0x3a, 0xca, 0x83, 0x43,
	0xa3, 0x94, 0x65, 0x71, 0xc6, 0x7c, 0x79, 0x8d, 0x53, 0xbb, 0xda, 0x29, 0xcd, 0xc1, 0xf7, 0xb5,
	0xdf, 0x16, 0xde, 0xa8, 0xf4, 0x73, 0xb4, 0x48, 0x19, 0x1e, 0x42, 0x4d, 0xb7, 0x33, 0xd5, 0x02,
	0x47, 0x36, 0x7a, 0x66, 0xec, 0x9d, 0x3e, 0x4a, 0xd8, 0xa1, 0xcf, 0x7c, 0xf5, 0x24, 0xd9, 0xab,
	0x83, 0x47, 0x1d, 0xe2, 0x9d, 0x52, 0xcb, 0xa1, 0xa2, 0x59, 0x59, 0xa7, 0x9c, 0x60, 0x95, 0x5f,
	0xef, 0xb4, 0x7d, 0xae, 0x69, 0x0c, 0xc2, 0xf3, 0x63, 0x18, 0x05, 0xe9, 0x41, 0xf3, 0x80, 0xca,
	0x5e, 0x4c, 0x42, 0x41, 0x1c, 0xf5, 0x8d, 0xda, 0x3b, 0xd7, 0x9d, 0x73, 0x7e, 0xc4, 0x54, 0xb7,
	0x15, 0xc8, 0x0d, 0x8d, 0x5c, 0x46, 0x4b, 0x39, 0x52, 0x16, 0x0c, 0xb4, 0x0b, 0xb7, 0x75, 0xb7,
	0xa8, 0xaa, 0x90, 0x85, 0x12, 0x4a, 0xb7, 0x87, 0xa6, 0x26, 0xd5, 0xd1, 0x5c, 0x4e, 0xf2, 0x55,
	0xea, 0x09, 0xc0, 0x2b, 0x12, 0xf8, 0x2e, 0x91, 0x3c, 0x16, 0x37, 0xb6, 0xc1, 0x42, 0x3a, 0xd9,
	0x6d, 0x06, 0x05, 0xe6, 0x3b, 0xb8, 0x6b, 0xf1, 0x98, 0xbe, 0xa2, 0xb1, 0x50, 0xcb, 0xac, 0xa2,
	0x96, 0x6b, 0xaa, 0xa4, 0xc5, 0x6d, 0x8d, 0x5d, 0x41, 0xcd, 0x1c, 0xeb, 0xf0, 0x98, 0xda, 0x83,
	0x8c, 0xd4, 0x03, 0x38, 0x24, 0x42, 0x66, 0xdf, 0xcc, 0x9b, 0x56, 0x5b, 0x48, 0x27, 0xb7, 0x31,
	0x50, 0x55, 0xd3, 0x4f, 0x39, 0xdf, 0x43, 0xfd, 0x35, 0x39, 0x49, 0xe2, 0x01, 0xf5, 0x83, 0x80,
	0x84, 0x4e, 0x75, 0x63, 0x5c, 0x2d, 0x7f, 0xa3, 0x4a, 0xe2, 0xc9, 0x5e, 0xf5, 0x13, 0xb1, 0x45,
	0x99, 0xf6, 0x0d, 0xd4, 0x8e, 0xa8, 0xbc, 0xf6, 0xa4, 0xca, 0x9f, 0xac, 0x4c, 0x97, 0x57, 0x12,
	0x5a, 0x1c, 0xb5, 0x0b, 0x2a, 0x6d, 0x7d, 0x60, 0xc7, 0x30, 0xbb, 0x17, 0x10, 0xe7, 0x6d, 0xe0,
	0x8b, 0x9b, 0x77, 0xa0, 0x4b, 0xcf, 0x12, 0x41, 0x0f, 0x7d, 0x21, 0xf1, 0xba, 0x26, 0x2e, 0xa1,
	0x46, 0xf1, 0x75, 0xc8, 0x28, 0x7b, 0xc7, 0xbf, 0xec, 0x02, 0x9a, 0x7e, 0x7c, 0xeb, 0xd1, 0xce,
	0xa7, 0xdb, 0x86, 0xf1, 0xfe, 0xa2, 0x63, 0xfc, 0x79, 0xd1, 0x31, 0xfe, 0xbe, 0xe8, 0x18, 0xbf,
	0x5d, 0x76, 0xfe, 0xf7, 0xc7, 0x65, 0xc7, 0x78, 0x7f, 0xd9, 0x31, 0x5e, 0x6f, 0x7b, 0xbe, 0xec,
	0x27, 0xa7, 0x3b, 0x0e, 0x67, 0xa6, 0x4b, 0xa2, 0x28, 0xa0, 0xae, 0xfa, 0xff, 0xda, 0x0d, 0x43,
	0xfd, 0x1f, 0x64, 0x96, 0xfe, 0x05, 0x4f, 0x67, 0xf4, 0xe5, 0xb3, 0x7f, 0x03, 0x00, 0x00, 0xff,
	0xff, 0xba, 0xab, 0xd0, 0x6c, 0x21, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RpcServiceClient is the client API for RpcService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RpcServiceClient interface {
	Status(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultStatus, error)
	Genesis(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultGenesis, error)
	Health(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultHealthInfo, error)
	Block(ctx context.Context, in *CmdBlock, opts ...grpc.CallOption) (*rpc.ResultBlock, error)
	BlockchainInfo(ctx context.Context, in *CmdBlockchainInfo, opts ...grpc.CallOption) (*rpc.ResultBlockchainInfo, error)
	DumpConsensusState(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultDumpConsensusState, error)
	UnconfirmedTxs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultUnconfirmedTxs, error)
	NumUnconfirmedTxs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultUnconfirmedTxs, error)
	NumArchivedBlocks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultNumArchivedBlocks, error)
	UnsafeFlushMempool(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultUnsafeFlushMempool, error)
	BroadcastTx(ctx context.Context, in *CmdBroadcastTx, opts ...grpc.CallOption) (*rpc.ResultBroadcastTx, error)
	BroadcastTxCommit(ctx context.Context, in *CmdBroadcastTx, opts ...grpc.CallOption) (*rpc.ResultBroadcastTxCommit, error)
	QueryTx(ctx context.Context, in *CmdQuery, opts ...grpc.CallOption) (*rpc.ResultNumLimitTx, error)
	Query(ctx context.Context, in *CmdQuery, opts ...grpc.CallOption) (*rpc.ResultQuery, error)
	GetTransactionByHash(ctx context.Context, in *CmdHash, opts ...grpc.CallOption) (*rpc.ResultQuery, error)
	Info(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultInfo, error)
	Validators(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultValidators, error)
	CoreVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultCoreVersion, error)
	LastHeight(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultLastHeight, error)
	ZaSurveillance(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultSurveillance, error)
	NetInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultNetInfo, error)
	Blacklist(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultRefuseList, error)
}

type rpcServiceClient struct {
	cc *grpc.ClientConn
}

func NewRpcServiceClient(cc *grpc.ClientConn) RpcServiceClient {
	return &rpcServiceClient{cc}
}

func (c *rpcServiceClient) Status(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultStatus, error) {
	out := new(rpc.ResultStatus)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) Genesis(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultGenesis, error) {
	out := new(rpc.ResultGenesis)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/Genesis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) Health(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultHealthInfo, error) {
	out := new(rpc.ResultHealthInfo)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/Health", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) Block(ctx context.Context, in *CmdBlock, opts ...grpc.CallOption) (*rpc.ResultBlock, error) {
	out := new(rpc.ResultBlock)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/Block", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) BlockchainInfo(ctx context.Context, in *CmdBlockchainInfo, opts ...grpc.CallOption) (*rpc.ResultBlockchainInfo, error) {
	out := new(rpc.ResultBlockchainInfo)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/BlockchainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) DumpConsensusState(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultDumpConsensusState, error) {
	out := new(rpc.ResultDumpConsensusState)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/DumpConsensusState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) UnconfirmedTxs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultUnconfirmedTxs, error) {
	out := new(rpc.ResultUnconfirmedTxs)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/UnconfirmedTxs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) NumUnconfirmedTxs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultUnconfirmedTxs, error) {
	out := new(rpc.ResultUnconfirmedTxs)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/NumUnconfirmedTxs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) NumArchivedBlocks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultNumArchivedBlocks, error) {
	out := new(rpc.ResultNumArchivedBlocks)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/NumArchivedBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) UnsafeFlushMempool(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultUnsafeFlushMempool, error) {
	out := new(rpc.ResultUnsafeFlushMempool)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/UnsafeFlushMempool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) BroadcastTx(ctx context.Context, in *CmdBroadcastTx, opts ...grpc.CallOption) (*rpc.ResultBroadcastTx, error) {
	out := new(rpc.ResultBroadcastTx)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/BroadcastTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) BroadcastTxCommit(ctx context.Context, in *CmdBroadcastTx, opts ...grpc.CallOption) (*rpc.ResultBroadcastTxCommit, error) {
	out := new(rpc.ResultBroadcastTxCommit)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/BroadcastTxCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) QueryTx(ctx context.Context, in *CmdQuery, opts ...grpc.CallOption) (*rpc.ResultNumLimitTx, error) {
	out := new(rpc.ResultNumLimitTx)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/QueryTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) Query(ctx context.Context, in *CmdQuery, opts ...grpc.CallOption) (*rpc.ResultQuery, error) {
	out := new(rpc.ResultQuery)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) GetTransactionByHash(ctx context.Context, in *CmdHash, opts ...grpc.CallOption) (*rpc.ResultQuery, error) {
	out := new(rpc.ResultQuery)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/GetTransactionByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) Info(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultInfo, error) {
	out := new(rpc.ResultInfo)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) Validators(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultValidators, error) {
	out := new(rpc.ResultValidators)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/Validators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) CoreVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultCoreVersion, error) {
	out := new(rpc.ResultCoreVersion)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/CoreVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) LastHeight(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultLastHeight, error) {
	out := new(rpc.ResultLastHeight)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/LastHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) ZaSurveillance(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultSurveillance, error) {
	out := new(rpc.ResultSurveillance)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/ZaSurveillance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) NetInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultNetInfo, error) {
	out := new(rpc.ResultNetInfo)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/NetInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcServiceClient) Blacklist(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*rpc.ResultRefuseList, error) {
	out := new(rpc.ResultRefuseList)
	err := c.cc.Invoke(ctx, "/grpc.RpcService/Blacklist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RpcServiceServer is the server API for RpcService service.
type RpcServiceServer interface {
	Status(context.Context, *EmptyRequest) (*rpc.ResultStatus, error)
	Genesis(context.Context, *EmptyRequest) (*rpc.ResultGenesis, error)
	Health(context.Context, *EmptyRequest) (*rpc.ResultHealthInfo, error)
	Block(context.Context, *CmdBlock) (*rpc.ResultBlock, error)
	BlockchainInfo(context.Context, *CmdBlockchainInfo) (*rpc.ResultBlockchainInfo, error)
	DumpConsensusState(context.Context, *EmptyRequest) (*rpc.ResultDumpConsensusState, error)
	UnconfirmedTxs(context.Context, *EmptyRequest) (*rpc.ResultUnconfirmedTxs, error)
	NumUnconfirmedTxs(context.Context, *EmptyRequest) (*rpc.ResultUnconfirmedTxs, error)
	NumArchivedBlocks(context.Context, *EmptyRequest) (*rpc.ResultNumArchivedBlocks, error)
	UnsafeFlushMempool(context.Context, *EmptyRequest) (*rpc.ResultUnsafeFlushMempool, error)
	BroadcastTx(context.Context, *CmdBroadcastTx) (*rpc.ResultBroadcastTx, error)
	BroadcastTxCommit(context.Context, *CmdBroadcastTx) (*rpc.ResultBroadcastTxCommit, error)
	QueryTx(context.Context, *CmdQuery) (*rpc.ResultNumLimitTx, error)
	Query(context.Context, *CmdQuery) (*rpc.ResultQuery, error)
	GetTransactionByHash(context.Context, *CmdHash) (*rpc.ResultQuery, error)
	Info(context.Context, *EmptyRequest) (*rpc.ResultInfo, error)
	Validators(context.Context, *EmptyRequest) (*rpc.ResultValidators, error)
	CoreVersion(context.Context, *EmptyRequest) (*rpc.ResultCoreVersion, error)
	LastHeight(context.Context, *EmptyRequest) (*rpc.ResultLastHeight, error)
	ZaSurveillance(context.Context, *EmptyRequest) (*rpc.ResultSurveillance, error)
	NetInfo(context.Context, *EmptyRequest) (*rpc.ResultNetInfo, error)
	Blacklist(context.Context, *EmptyRequest) (*rpc.ResultRefuseList, error)
}

// UnimplementedRpcServiceServer can be embedded to have forward compatible implementations.
type UnimplementedRpcServiceServer struct {
}

func (*UnimplementedRpcServiceServer) Status(ctx context.Context, req *EmptyRequest) (*rpc.ResultStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (*UnimplementedRpcServiceServer) Genesis(ctx context.Context, req *EmptyRequest) (*rpc.ResultGenesis, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Genesis not implemented")
}
func (*UnimplementedRpcServiceServer) Health(ctx context.Context, req *EmptyRequest) (*rpc.ResultHealthInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}
func (*UnimplementedRpcServiceServer) Block(ctx context.Context, req *CmdBlock) (*rpc.ResultBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Block not implemented")
}
func (*UnimplementedRpcServiceServer) BlockchainInfo(ctx context.Context, req *CmdBlockchainInfo) (*rpc.ResultBlockchainInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockchainInfo not implemented")
}
func (*UnimplementedRpcServiceServer) DumpConsensusState(ctx context.Context, req *EmptyRequest) (*rpc.ResultDumpConsensusState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpConsensusState not implemented")
}
func (*UnimplementedRpcServiceServer) UnconfirmedTxs(ctx context.Context, req *EmptyRequest) (*rpc.ResultUnconfirmedTxs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnconfirmedTxs not implemented")
}
func (*UnimplementedRpcServiceServer) NumUnconfirmedTxs(ctx context.Context, req *EmptyRequest) (*rpc.ResultUnconfirmedTxs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NumUnconfirmedTxs not implemented")
}
func (*UnimplementedRpcServiceServer) NumArchivedBlocks(ctx context.Context, req *EmptyRequest) (*rpc.ResultNumArchivedBlocks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NumArchivedBlocks not implemented")
}
func (*UnimplementedRpcServiceServer) UnsafeFlushMempool(ctx context.Context, req *EmptyRequest) (*rpc.ResultUnsafeFlushMempool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsafeFlushMempool not implemented")
}
func (*UnimplementedRpcServiceServer) BroadcastTx(ctx context.Context, req *CmdBroadcastTx) (*rpc.ResultBroadcastTx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastTx not implemented")
}
func (*UnimplementedRpcServiceServer) BroadcastTxCommit(ctx context.Context, req *CmdBroadcastTx) (*rpc.ResultBroadcastTxCommit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastTxCommit not implemented")
}
func (*UnimplementedRpcServiceServer) QueryTx(ctx context.Context, req *CmdQuery) (*rpc.ResultNumLimitTx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTx not implemented")
}
func (*UnimplementedRpcServiceServer) Query(ctx context.Context, req *CmdQuery) (*rpc.ResultQuery, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (*UnimplementedRpcServiceServer) GetTransactionByHash(ctx context.Context, req *CmdHash) (*rpc.ResultQuery, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionByHash not implemented")
}
func (*UnimplementedRpcServiceServer) Info(ctx context.Context, req *EmptyRequest) (*rpc.ResultInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (*UnimplementedRpcServiceServer) Validators(ctx context.Context, req *EmptyRequest) (*rpc.ResultValidators, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Validators not implemented")
}
func (*UnimplementedRpcServiceServer) CoreVersion(ctx context.Context, req *EmptyRequest) (*rpc.ResultCoreVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CoreVersion not implemented")
}
func (*UnimplementedRpcServiceServer) LastHeight(ctx context.Context, req *EmptyRequest) (*rpc.ResultLastHeight, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LastHeight not implemented")
}
func (*UnimplementedRpcServiceServer) ZaSurveillance(ctx context.Context, req *EmptyRequest) (*rpc.ResultSurveillance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZaSurveillance not implemented")
}
func (*UnimplementedRpcServiceServer) NetInfo(ctx context.Context, req *EmptyRequest) (*rpc.ResultNetInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NetInfo not implemented")
}
func (*UnimplementedRpcServiceServer) Blacklist(ctx context.Context, req *EmptyRequest) (*rpc.ResultRefuseList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Blacklist not implemented")
}

func RegisterRpcServiceServer(s *grpc.Server, srv RpcServiceServer) {
	s.RegisterService(&_RpcService_serviceDesc, srv)
}

func _RpcService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).Status(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_Genesis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).Genesis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/Genesis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).Genesis(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).Health(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_Block_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmdBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).Block(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/Block",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).Block(ctx, req.(*CmdBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_BlockchainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmdBlockchainInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).BlockchainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/BlockchainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).BlockchainInfo(ctx, req.(*CmdBlockchainInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_DumpConsensusState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).DumpConsensusState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/DumpConsensusState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).DumpConsensusState(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_UnconfirmedTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).UnconfirmedTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/UnconfirmedTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).UnconfirmedTxs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_NumUnconfirmedTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).NumUnconfirmedTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/NumUnconfirmedTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).NumUnconfirmedTxs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_NumArchivedBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).NumArchivedBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/NumArchivedBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).NumArchivedBlocks(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_UnsafeFlushMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).UnsafeFlushMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/UnsafeFlushMempool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).UnsafeFlushMempool(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_BroadcastTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmdBroadcastTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).BroadcastTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/BroadcastTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).BroadcastTx(ctx, req.(*CmdBroadcastTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_BroadcastTxCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmdBroadcastTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).BroadcastTxCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/BroadcastTxCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).BroadcastTxCommit(ctx, req.(*CmdBroadcastTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_QueryTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmdQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).QueryTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/QueryTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).QueryTx(ctx, req.(*CmdQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmdQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).Query(ctx, req.(*CmdQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_GetTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmdHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).GetTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/GetTransactionByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).GetTransactionByHash(ctx, req.(*CmdHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).Info(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_Validators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).Validators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/Validators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).Validators(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_CoreVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).CoreVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/CoreVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).CoreVersion(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_LastHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).LastHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/LastHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).LastHeight(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_ZaSurveillance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).ZaSurveillance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/ZaSurveillance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).ZaSurveillance(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_NetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).NetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/NetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).NetInfo(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcService_Blacklist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcServiceServer).Blacklist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.RpcService/Blacklist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcServiceServer).Blacklist(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RpcService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.RpcService",
	HandlerType: (*RpcServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _RpcService_Status_Handler,
		},
		{
			MethodName: "Genesis",
			Handler:    _RpcService_Genesis_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _RpcService_Health_Handler,
		},
		{
			MethodName: "Block",
			Handler:    _RpcService_Block_Handler,
		},
		{
			MethodName: "BlockchainInfo",
			Handler:    _RpcService_BlockchainInfo_Handler,
		},
		{
			MethodName: "DumpConsensusState",
			Handler:    _RpcService_DumpConsensusState_Handler,
		},
		{
			MethodName: "UnconfirmedTxs",
			Handler:    _RpcService_UnconfirmedTxs_Handler,
		},
		{
			MethodName: "NumUnconfirmedTxs",
			Handler:    _RpcService_NumUnconfirmedTxs_Handler,
		},
		{
			MethodName: "NumArchivedBlocks",
			Handler:    _RpcService_NumArchivedBlocks_Handler,
		},
		{
			MethodName: "UnsafeFlushMempool",
			Handler:    _RpcService_UnsafeFlushMempool_Handler,
		},
		{
			MethodName: "BroadcastTx",
			Handler:    _RpcService_BroadcastTx_Handler,
		},
		{
			MethodName: "BroadcastTxCommit",
			Handler:    _RpcService_BroadcastTxCommit_Handler,
		},
		{
			MethodName: "QueryTx",
			Handler:    _RpcService_QueryTx_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _RpcService_Query_Handler,
		},
		{
			MethodName: "GetTransactionByHash",
			Handler:    _RpcService_GetTransactionByHash_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _RpcService_Info_Handler,
		},
		{
			MethodName: "Validators",
			Handler:    _RpcService_Validators_Handler,
		},
		{
			MethodName: "CoreVersion",
			Handler:    _RpcService_CoreVersion_Handler,
		},
		{
			MethodName: "LastHeight",
			Handler:    _RpcService_LastHeight_Handler,
		},
		{
			MethodName: "ZaSurveillance",
			Handler:    _RpcService_ZaSurveillance_Handler,
		},
		{
			MethodName: "NetInfo",
			Handler:    _RpcService_NetInfo_Handler,
		},
		{
			MethodName: "Blacklist",
			Handler:    _RpcService_Blacklist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chain/proto/grpc.proto",
}

func (m *EmptyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CmdChainID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdChainID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdChainID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChainID) > 0 {
		i -= len(m.ChainID)
		copy(dAtA[i:], m.ChainID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.ChainID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CmdRequestSpecialOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdRequestSpecialOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdRequestSpecialOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainID) > 0 {
		i -= len(m.ChainID)
		copy(dAtA[i:], m.ChainID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.ChainID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CmdBlockchainInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdBlockchainInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdBlockchainInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxHeight != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.MaxHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.MinHeight != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.MinHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CmdBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Height != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CmdBroadcastTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdBroadcastTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdBroadcastTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CmdQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CmdEventCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdEventCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdEventCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CodeHash) > 0 {
		i -= len(m.CodeHash)
		copy(dAtA[i:], m.CodeHash)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.CodeHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CmdHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CmdHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CmdHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGrpc(dAtA []byte, offset int, v uint64) int {
	offset -= sovGrpc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EmptyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CmdChainID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CmdRequestSpecialOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CmdBlockchainInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinHeight != 0 {
		n += 1 + sovGrpc(uint64(m.MinHeight))
	}
	if m.MaxHeight != 0 {
		n += 1 + sovGrpc(uint64(m.MaxHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CmdBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovGrpc(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CmdBroadcastTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CmdQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CmdEventCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CodeHash)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CmdHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGrpc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGrpc(x uint64) (n int) {
	return sovGrpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdChainID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdChainID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdChainID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdRequestSpecialOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdRequestSpecialOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdRequestSpecialOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = append(m.Tx[:0], dAtA[iNdEx:postIndex]...)
			if m.Tx == nil {
				m.Tx = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdBlockchainInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdBlockchainInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdBlockchainInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHeight", wireType)
			}
			m.MinHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHeight", wireType)
			}
			m.MaxHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdBroadcastTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdBroadcastTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdBroadcastTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = append(m.Tx[:0], dAtA[iNdEx:postIndex]...)
			if m.Tx == nil {
				m.Tx = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = append(m.Query[:0], dAtA[iNdEx:postIndex]...)
			if m.Query == nil {
				m.Query = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdEventCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdEventCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdEventCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeHash = append(m.CodeHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CodeHash == nil {
				m.CodeHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CmdHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CmdHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CmdHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGrpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGrpc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGrpc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGrpc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGrpc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGrpc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGrpc = fmt.Errorf("proto: unexpected end of group")
)
