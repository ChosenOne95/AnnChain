// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gemmill/protos/rpc/rpc.proto

package rpc

import (
	fmt "fmt"
	crypto "github.com/dappledger/AnnChain/gemmill/protos/crypto"
	events "github.com/dappledger/AnnChain/gemmill/protos/events"
	p2p "github.com/dappledger/AnnChain/gemmill/protos/p2p"
	types "github.com/dappledger/AnnChain/gemmill/protos/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Type int32

const (
	Type_RpcNone            Type = 0
	Type_RpcGenesis         Type = 1
	Type_RpcBlockchainInfo  Type = 2
	Type_RpcBlock           Type = 3
	Type_RpcNonEmptyHeights Type = 4
	// 0x2 bytes are for the network
	Type_RpcStatus    Type = 32
	Type_RpcNetInfo   Type = 33
	Type_RpcDialSeeds Type = 34
	Type_RpcOrgs      Type = 35
	// 0x1  bytes are for refuseList
	Type_RpcRefuseList Type = 16
	// 0x4 bytes are for the consensus
	Type_RpcValidators         Type = 64
	Type_RpcDumpConsensusState Type = 65
	// 0x6 bytes are for txs / the application
	Type_RpcBroadcastTx       Type = 96
	Type_RpcUnconfirmedTxs    Type = 97
	Type_RpcBroadcastTxCommit Type = 98
	Type_RpcRequestSpecialOP  Type = 99
	// 0x7 bytes are for querying the application
	Type_RpcQuery Type = 112
	Type_RpcInfo  Type = 113
	// 0x8 bytes are for events
	Type_RpcSubscribe   Type = 128
	Type_RpcUnsubscribe Type = 129
	Type_RpcEvent       Type = 130
	// 0xa bytes for testing
	Type_RpcUnsafeSetConfig        Type = 160
	Type_RpcUnsafeStartCPUProfiler Type = 161
	Type_RpcUnsafeStopCPUProfiler  Type = 162
	Type_RpcUnsafeWriteHeapProfile Type = 163
	Type_RpcUnsafeFlushMempool     Type = 164
	Type_RpcCoreVersion            Type = 175
	// 0x9 bytes are for za_surveillance
	Type_RpcSurveillance Type = 144
)

var Type_name = map[int32]string{
	0:   "RpcNone",
	1:   "RpcGenesis",
	2:   "RpcBlockchainInfo",
	3:   "RpcBlock",
	4:   "RpcNonEmptyHeights",
	32:  "RpcStatus",
	33:  "RpcNetInfo",
	34:  "RpcDialSeeds",
	35:  "RpcOrgs",
	16:  "RpcRefuseList",
	64:  "RpcValidators",
	65:  "RpcDumpConsensusState",
	96:  "RpcBroadcastTx",
	97:  "RpcUnconfirmedTxs",
	98:  "RpcBroadcastTxCommit",
	99:  "RpcRequestSpecialOP",
	112: "RpcQuery",
	113: "RpcInfo",
	128: "RpcSubscribe",
	129: "RpcUnsubscribe",
	130: "RpcEvent",
	160: "RpcUnsafeSetConfig",
	161: "RpcUnsafeStartCPUProfiler",
	162: "RpcUnsafeStopCPUProfiler",
	163: "RpcUnsafeWriteHeapProfile",
	164: "RpcUnsafeFlushMempool",
	175: "RpcCoreVersion",
	144: "RpcSurveillance",
}

var Type_value = map[string]int32{
	"RpcNone":                   0,
	"RpcGenesis":                1,
	"RpcBlockchainInfo":         2,
	"RpcBlock":                  3,
	"RpcNonEmptyHeights":        4,
	"RpcStatus":                 32,
	"RpcNetInfo":                33,
	"RpcDialSeeds":              34,
	"RpcOrgs":                   35,
	"RpcRefuseList":             16,
	"RpcValidators":             64,
	"RpcDumpConsensusState":     65,
	"RpcBroadcastTx":            96,
	"RpcUnconfirmedTxs":         97,
	"RpcBroadcastTxCommit":      98,
	"RpcRequestSpecialOP":       99,
	"RpcQuery":                  112,
	"RpcInfo":                   113,
	"RpcSubscribe":              128,
	"RpcUnsubscribe":            129,
	"RpcEvent":                  130,
	"RpcUnsafeSetConfig":        160,
	"RpcUnsafeStartCPUProfiler": 161,
	"RpcUnsafeStopCPUProfiler":  162,
	"RpcUnsafeWriteHeapProfile": 163,
	"RpcUnsafeFlushMempool":     164,
	"RpcCoreVersion":            175,
	"RpcSurveillance":           144,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{0}
}

type ResultBlockchainInfo struct {
	LastHeight           int64              `protobuf:"varint,1,opt,name=LastHeight,proto3" json:"LastHeight,omitempty"`
	BlockMetas           []*types.BlockMeta `protobuf:"bytes,2,rep,name=BlockMetas,proto3" json:"BlockMetas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ResultBlockchainInfo) Reset()         { *m = ResultBlockchainInfo{} }
func (m *ResultBlockchainInfo) String() string { return proto.CompactTextString(m) }
func (*ResultBlockchainInfo) ProtoMessage()    {}
func (*ResultBlockchainInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{0}
}
func (m *ResultBlockchainInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultBlockchainInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultBlockchainInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultBlockchainInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultBlockchainInfo.Merge(m, src)
}
func (m *ResultBlockchainInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResultBlockchainInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultBlockchainInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResultBlockchainInfo proto.InternalMessageInfo

func (m *ResultBlockchainInfo) GetLastHeight() int64 {
	if m != nil {
		return m.LastHeight
	}
	return 0
}

func (m *ResultBlockchainInfo) GetBlockMetas() []*types.BlockMeta {
	if m != nil {
		return m.BlockMetas
	}
	return nil
}

type ResultGenesis struct {
	Genesis              *types.GenesisDoc `protobuf:"bytes,1,opt,name=Genesis,proto3" json:"Genesis,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ResultGenesis) Reset()         { *m = ResultGenesis{} }
func (m *ResultGenesis) String() string { return proto.CompactTextString(m) }
func (*ResultGenesis) ProtoMessage()    {}
func (*ResultGenesis) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{1}
}
func (m *ResultGenesis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultGenesis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultGenesis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultGenesis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultGenesis.Merge(m, src)
}
func (m *ResultGenesis) XXX_Size() int {
	return m.Size()
}
func (m *ResultGenesis) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultGenesis.DiscardUnknown(m)
}

var xxx_messageInfo_ResultGenesis proto.InternalMessageInfo

func (m *ResultGenesis) GetGenesis() *types.GenesisDoc {
	if m != nil {
		return m.Genesis
	}
	return nil
}

type ResultBlock struct {
	BlockMeta            *types.BlockMeta `protobuf:"bytes,1,opt,name=BlockMeta,proto3" json:"BlockMeta,omitempty"`
	Block                *types.Block     `protobuf:"bytes,2,opt,name=Block,proto3" json:"Block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ResultBlock) Reset()         { *m = ResultBlock{} }
func (m *ResultBlock) String() string { return proto.CompactTextString(m) }
func (*ResultBlock) ProtoMessage()    {}
func (*ResultBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{2}
}
func (m *ResultBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultBlock.Merge(m, src)
}
func (m *ResultBlock) XXX_Size() int {
	return m.Size()
}
func (m *ResultBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultBlock.DiscardUnknown(m)
}

var xxx_messageInfo_ResultBlock proto.InternalMessageInfo

func (m *ResultBlock) GetBlockMeta() *types.BlockMeta {
	if m != nil {
		return m.BlockMeta
	}
	return nil
}

func (m *ResultBlock) GetBlock() *types.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

type ResultOrgs struct {
	Names                []string `protobuf:"bytes,1,rep,name=Names,proto3" json:"Names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultOrgs) Reset()         { *m = ResultOrgs{} }
func (m *ResultOrgs) String() string { return proto.CompactTextString(m) }
func (*ResultOrgs) ProtoMessage()    {}
func (*ResultOrgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{3}
}
func (m *ResultOrgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultOrgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultOrgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultOrgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultOrgs.Merge(m, src)
}
func (m *ResultOrgs) XXX_Size() int {
	return m.Size()
}
func (m *ResultOrgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultOrgs.DiscardUnknown(m)
}

var xxx_messageInfo_ResultOrgs proto.InternalMessageInfo

func (m *ResultOrgs) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type ResultStatus struct {
	NodeInfo             *p2p.NodeInfo  `protobuf:"bytes,1,opt,name=NodeInfo,proto3" json:"NodeInfo,omitempty"`
	PubKey               *crypto.PubKey `protobuf:"bytes,2,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	LatestBlockHash      []byte         `protobuf:"bytes,3,opt,name=LatestBlockHash,proto3" json:"LatestBlockHash,omitempty"`
	LatestAppHash        []byte         `protobuf:"bytes,4,opt,name=LatestAppHash,proto3" json:"LatestAppHash,omitempty"`
	LatestBlockHeight    int64          `protobuf:"varint,5,opt,name=LatestBlockHeight,proto3" json:"LatestBlockHeight,omitempty"`
	LatestBlockTime      int64          `protobuf:"varint,6,opt,name=LatestBlockTime,proto3" json:"LatestBlockTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ResultStatus) Reset()         { *m = ResultStatus{} }
func (m *ResultStatus) String() string { return proto.CompactTextString(m) }
func (*ResultStatus) ProtoMessage()    {}
func (*ResultStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{4}
}
func (m *ResultStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultStatus.Merge(m, src)
}
func (m *ResultStatus) XXX_Size() int {
	return m.Size()
}
func (m *ResultStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ResultStatus proto.InternalMessageInfo

func (m *ResultStatus) GetNodeInfo() *p2p.NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *ResultStatus) GetPubKey() *crypto.PubKey {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *ResultStatus) GetLatestBlockHash() []byte {
	if m != nil {
		return m.LatestBlockHash
	}
	return nil
}

func (m *ResultStatus) GetLatestAppHash() []byte {
	if m != nil {
		return m.LatestAppHash
	}
	return nil
}

func (m *ResultStatus) GetLatestBlockHeight() int64 {
	if m != nil {
		return m.LatestBlockHeight
	}
	return 0
}

func (m *ResultStatus) GetLatestBlockTime() int64 {
	if m != nil {
		return m.LatestBlockTime
	}
	return 0
}

type Peer struct {
	NodeInfo             *p2p.NodeInfo         `protobuf:"bytes,1,opt,name=NodeInfo,proto3" json:"NodeInfo,omitempty"`
	IsOutbound           bool                  `protobuf:"varint,2,opt,name=IsOutbound,proto3" json:"IsOutbound,omitempty"`
	ConnectionStatus     *p2p.ConnectionStatus `protobuf:"bytes,3,opt,name=ConnectionStatus,proto3" json:"ConnectionStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{5}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetNodeInfo() *p2p.NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *Peer) GetIsOutbound() bool {
	if m != nil {
		return m.IsOutbound
	}
	return false
}

func (m *Peer) GetConnectionStatus() *p2p.ConnectionStatus {
	if m != nil {
		return m.ConnectionStatus
	}
	return nil
}

type ResultNetInfo struct {
	Listening            bool     `protobuf:"varint,1,opt,name=Listening,proto3" json:"Listening,omitempty"`
	Listeners            []string `protobuf:"bytes,2,rep,name=Listeners,proto3" json:"Listeners,omitempty"`
	Peers                []*Peer  `protobuf:"bytes,3,rep,name=peers,proto3" json:"peers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultNetInfo) Reset()         { *m = ResultNetInfo{} }
func (m *ResultNetInfo) String() string { return proto.CompactTextString(m) }
func (*ResultNetInfo) ProtoMessage()    {}
func (*ResultNetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{6}
}
func (m *ResultNetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultNetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultNetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultNetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultNetInfo.Merge(m, src)
}
func (m *ResultNetInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResultNetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultNetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResultNetInfo proto.InternalMessageInfo

func (m *ResultNetInfo) GetListening() bool {
	if m != nil {
		return m.Listening
	}
	return false
}

func (m *ResultNetInfo) GetListeners() []string {
	if m != nil {
		return m.Listeners
	}
	return nil
}

func (m *ResultNetInfo) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type ResultValidators struct {
	BlockHeight          int64              `protobuf:"varint,1,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	Validators           []*ResultValidator `protobuf:"bytes,2,rep,name=Validators,proto3" json:"Validators,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ResultValidators) Reset()         { *m = ResultValidators{} }
func (m *ResultValidators) String() string { return proto.CompactTextString(m) }
func (*ResultValidators) ProtoMessage()    {}
func (*ResultValidators) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{7}
}
func (m *ResultValidators) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultValidators) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultValidators.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultValidators) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultValidators.Merge(m, src)
}
func (m *ResultValidators) XXX_Size() int {
	return m.Size()
}
func (m *ResultValidators) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultValidators.DiscardUnknown(m)
}

var xxx_messageInfo_ResultValidators proto.InternalMessageInfo

func (m *ResultValidators) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ResultValidators) GetValidators() []*ResultValidator {
	if m != nil {
		return m.Validators
	}
	return nil
}

type ResultDumpConsensusState struct {
	RoundState           string   `protobuf:"bytes,1,opt,name=RoundState,proto3" json:"RoundState,omitempty"`
	PeerRoundStates      []string `protobuf:"bytes,2,rep,name=PeerRoundStates,proto3" json:"PeerRoundStates,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultDumpConsensusState) Reset()         { *m = ResultDumpConsensusState{} }
func (m *ResultDumpConsensusState) String() string { return proto.CompactTextString(m) }
func (*ResultDumpConsensusState) ProtoMessage()    {}
func (*ResultDumpConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{8}
}
func (m *ResultDumpConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultDumpConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultDumpConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultDumpConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultDumpConsensusState.Merge(m, src)
}
func (m *ResultDumpConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ResultDumpConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultDumpConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ResultDumpConsensusState proto.InternalMessageInfo

func (m *ResultDumpConsensusState) GetRoundState() string {
	if m != nil {
		return m.RoundState
	}
	return ""
}

func (m *ResultDumpConsensusState) GetPeerRoundStates() []string {
	if m != nil {
		return m.PeerRoundStates
	}
	return nil
}

type ResultBroadcastTx struct {
	Code                 types.CodeType `protobuf:"varint,1,opt,name=Code,proto3,enum=types.CodeType" json:"Code,omitempty"`
	Data                 []byte         `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	TxHash               string         `protobuf:"bytes,3,opt,name=TxHash,proto3" json:"TxHash,omitempty"`
	Log                  string         `protobuf:"bytes,4,opt,name=Log,proto3" json:"Log,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ResultBroadcastTx) Reset()         { *m = ResultBroadcastTx{} }
func (m *ResultBroadcastTx) String() string { return proto.CompactTextString(m) }
func (*ResultBroadcastTx) ProtoMessage()    {}
func (*ResultBroadcastTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{9}
}
func (m *ResultBroadcastTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultBroadcastTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultBroadcastTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultBroadcastTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultBroadcastTx.Merge(m, src)
}
func (m *ResultBroadcastTx) XXX_Size() int {
	return m.Size()
}
func (m *ResultBroadcastTx) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultBroadcastTx.DiscardUnknown(m)
}

var xxx_messageInfo_ResultBroadcastTx proto.InternalMessageInfo

func (m *ResultBroadcastTx) GetCode() types.CodeType {
	if m != nil {
		return m.Code
	}
	return types.CodeType_OK
}

func (m *ResultBroadcastTx) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResultBroadcastTx) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *ResultBroadcastTx) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

type ResultRequestAdminOP struct {
	Code                 types.CodeType `protobuf:"varint,1,opt,name=Code,proto3,enum=types.CodeType" json:"Code,omitempty"`
	Data                 []byte         `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	Log                  string         `protobuf:"bytes,3,opt,name=Log,proto3" json:"Log,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ResultRequestAdminOP) Reset()         { *m = ResultRequestAdminOP{} }
func (m *ResultRequestAdminOP) String() string { return proto.CompactTextString(m) }
func (*ResultRequestAdminOP) ProtoMessage()    {}
func (*ResultRequestAdminOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{10}
}
func (m *ResultRequestAdminOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultRequestAdminOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultRequestAdminOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultRequestAdminOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultRequestAdminOP.Merge(m, src)
}
func (m *ResultRequestAdminOP) XXX_Size() int {
	return m.Size()
}
func (m *ResultRequestAdminOP) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultRequestAdminOP.DiscardUnknown(m)
}

var xxx_messageInfo_ResultRequestAdminOP proto.InternalMessageInfo

func (m *ResultRequestAdminOP) GetCode() types.CodeType {
	if m != nil {
		return m.Code
	}
	return types.CodeType_OK
}

func (m *ResultRequestAdminOP) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResultRequestAdminOP) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

type ResultBroadcastTxCommit struct {
	Code                 types.CodeType `protobuf:"varint,1,opt,name=Code,proto3,enum=types.CodeType" json:"Code,omitempty"`
	Data                 []byte         `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	TxHash               string         `protobuf:"bytes,3,opt,name=TxHash,proto3" json:"TxHash,omitempty"`
	Log                  string         `protobuf:"bytes,4,opt,name=Log,proto3" json:"Log,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ResultBroadcastTxCommit) Reset()         { *m = ResultBroadcastTxCommit{} }
func (m *ResultBroadcastTxCommit) String() string { return proto.CompactTextString(m) }
func (*ResultBroadcastTxCommit) ProtoMessage()    {}
func (*ResultBroadcastTxCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{11}
}
func (m *ResultBroadcastTxCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultBroadcastTxCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultBroadcastTxCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultBroadcastTxCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultBroadcastTxCommit.Merge(m, src)
}
func (m *ResultBroadcastTxCommit) XXX_Size() int {
	return m.Size()
}
func (m *ResultBroadcastTxCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultBroadcastTxCommit.DiscardUnknown(m)
}

var xxx_messageInfo_ResultBroadcastTxCommit proto.InternalMessageInfo

func (m *ResultBroadcastTxCommit) GetCode() types.CodeType {
	if m != nil {
		return m.Code
	}
	return types.CodeType_OK
}

func (m *ResultBroadcastTxCommit) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResultBroadcastTxCommit) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *ResultBroadcastTxCommit) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

type ResultUnconfirmedTxs struct {
	N                    int64    `protobuf:"varint,1,opt,name=N,proto3" json:"N,omitempty"`
	Txs                  [][]byte `protobuf:"bytes,2,rep,name=Txs,proto3" json:"Txs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultUnconfirmedTxs) Reset()         { *m = ResultUnconfirmedTxs{} }
func (m *ResultUnconfirmedTxs) String() string { return proto.CompactTextString(m) }
func (*ResultUnconfirmedTxs) ProtoMessage()    {}
func (*ResultUnconfirmedTxs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{12}
}
func (m *ResultUnconfirmedTxs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultUnconfirmedTxs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultUnconfirmedTxs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultUnconfirmedTxs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultUnconfirmedTxs.Merge(m, src)
}
func (m *ResultUnconfirmedTxs) XXX_Size() int {
	return m.Size()
}
func (m *ResultUnconfirmedTxs) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultUnconfirmedTxs.DiscardUnknown(m)
}

var xxx_messageInfo_ResultUnconfirmedTxs proto.InternalMessageInfo

func (m *ResultUnconfirmedTxs) GetN() int64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *ResultUnconfirmedTxs) GetTxs() [][]byte {
	if m != nil {
		return m.Txs
	}
	return nil
}

type ResultInfo struct {
	Data                 string   `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	LastBlockHeight      int64    `protobuf:"varint,3,opt,name=LastBlockHeight,proto3" json:"LastBlockHeight,omitempty"`
	LastBlockAppHash     []byte   `protobuf:"bytes,4,opt,name=LastBlockAppHash,proto3" json:"LastBlockAppHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultInfo) Reset()         { *m = ResultInfo{} }
func (m *ResultInfo) String() string { return proto.CompactTextString(m) }
func (*ResultInfo) ProtoMessage()    {}
func (*ResultInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{13}
}
func (m *ResultInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultInfo.Merge(m, src)
}
func (m *ResultInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResultInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResultInfo proto.InternalMessageInfo

func (m *ResultInfo) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ResultInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ResultInfo) GetLastBlockHeight() int64 {
	if m != nil {
		return m.LastBlockHeight
	}
	return 0
}

func (m *ResultInfo) GetLastBlockAppHash() []byte {
	if m != nil {
		return m.LastBlockAppHash
	}
	return nil
}

type ResultQuery struct {
	Result               *types.Result `protobuf:"bytes,1,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ResultQuery) Reset()         { *m = ResultQuery{} }
func (m *ResultQuery) String() string { return proto.CompactTextString(m) }
func (*ResultQuery) ProtoMessage()    {}
func (*ResultQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{14}
}
func (m *ResultQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultQuery.Merge(m, src)
}
func (m *ResultQuery) XXX_Size() int {
	return m.Size()
}
func (m *ResultQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ResultQuery proto.InternalMessageInfo

func (m *ResultQuery) GetResult() *types.Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type ResultRefuseList struct {
	Result               []string `protobuf:"bytes,1,rep,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultRefuseList) Reset()         { *m = ResultRefuseList{} }
func (m *ResultRefuseList) String() string { return proto.CompactTextString(m) }
func (*ResultRefuseList) ProtoMessage()    {}
func (*ResultRefuseList) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{15}
}
func (m *ResultRefuseList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultRefuseList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultRefuseList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultRefuseList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultRefuseList.Merge(m, src)
}
func (m *ResultRefuseList) XXX_Size() int {
	return m.Size()
}
func (m *ResultRefuseList) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultRefuseList.DiscardUnknown(m)
}

var xxx_messageInfo_ResultRefuseList proto.InternalMessageInfo

func (m *ResultRefuseList) GetResult() []string {
	if m != nil {
		return m.Result
	}
	return nil
}

type ResultUnsafeFlushMempool struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultUnsafeFlushMempool) Reset()         { *m = ResultUnsafeFlushMempool{} }
func (m *ResultUnsafeFlushMempool) String() string { return proto.CompactTextString(m) }
func (*ResultUnsafeFlushMempool) ProtoMessage()    {}
func (*ResultUnsafeFlushMempool) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{16}
}
func (m *ResultUnsafeFlushMempool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultUnsafeFlushMempool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultUnsafeFlushMempool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultUnsafeFlushMempool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultUnsafeFlushMempool.Merge(m, src)
}
func (m *ResultUnsafeFlushMempool) XXX_Size() int {
	return m.Size()
}
func (m *ResultUnsafeFlushMempool) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultUnsafeFlushMempool.DiscardUnknown(m)
}

var xxx_messageInfo_ResultUnsafeFlushMempool proto.InternalMessageInfo

type ResultUnsafeSetConfig struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultUnsafeSetConfig) Reset()         { *m = ResultUnsafeSetConfig{} }
func (m *ResultUnsafeSetConfig) String() string { return proto.CompactTextString(m) }
func (*ResultUnsafeSetConfig) ProtoMessage()    {}
func (*ResultUnsafeSetConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{17}
}
func (m *ResultUnsafeSetConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultUnsafeSetConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultUnsafeSetConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultUnsafeSetConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultUnsafeSetConfig.Merge(m, src)
}
func (m *ResultUnsafeSetConfig) XXX_Size() int {
	return m.Size()
}
func (m *ResultUnsafeSetConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultUnsafeSetConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ResultUnsafeSetConfig proto.InternalMessageInfo

type ResultUnsafeProfile struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultUnsafeProfile) Reset()         { *m = ResultUnsafeProfile{} }
func (m *ResultUnsafeProfile) String() string { return proto.CompactTextString(m) }
func (*ResultUnsafeProfile) ProtoMessage()    {}
func (*ResultUnsafeProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{18}
}
func (m *ResultUnsafeProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultUnsafeProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultUnsafeProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultUnsafeProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultUnsafeProfile.Merge(m, src)
}
func (m *ResultUnsafeProfile) XXX_Size() int {
	return m.Size()
}
func (m *ResultUnsafeProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultUnsafeProfile.DiscardUnknown(m)
}

var xxx_messageInfo_ResultUnsafeProfile proto.InternalMessageInfo

type ResultUnsubscribe struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultUnsubscribe) Reset()         { *m = ResultUnsubscribe{} }
func (m *ResultUnsubscribe) String() string { return proto.CompactTextString(m) }
func (*ResultUnsubscribe) ProtoMessage()    {}
func (*ResultUnsubscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{19}
}
func (m *ResultUnsubscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultUnsubscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultUnsubscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultUnsubscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultUnsubscribe.Merge(m, src)
}
func (m *ResultUnsubscribe) XXX_Size() int {
	return m.Size()
}
func (m *ResultUnsubscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultUnsubscribe.DiscardUnknown(m)
}

var xxx_messageInfo_ResultUnsubscribe proto.InternalMessageInfo

type ResultEvent struct {
	Name                 string           `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type                 events.EventType `protobuf:"varint,2,opt,name=Type,proto3,enum=events.EventType" json:"Type,omitempty"`
	Event                []byte           `protobuf:"bytes,3,opt,name=Event,proto3" json:"Event,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ResultEvent) Reset()         { *m = ResultEvent{} }
func (m *ResultEvent) String() string { return proto.CompactTextString(m) }
func (*ResultEvent) ProtoMessage()    {}
func (*ResultEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{20}
}
func (m *ResultEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultEvent.Merge(m, src)
}
func (m *ResultEvent) XXX_Size() int {
	return m.Size()
}
func (m *ResultEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ResultEvent proto.InternalMessageInfo

func (m *ResultEvent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResultEvent) GetType() events.EventType {
	if m != nil {
		return m.Type
	}
	return events.EventType_EventNewBlock
}

func (m *ResultEvent) GetEvent() []byte {
	if m != nil {
		return m.Event
	}
	return nil
}

type ResultSurveillance struct {
	NanoSecsPerTx        int64    `protobuf:"varint,1,opt,name=NanoSecsPerTx,proto3" json:"NanoSecsPerTx,omitempty"`
	Height               int64    `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=Addr,proto3" json:"Addr,omitempty"`
	IsValidator          bool     `protobuf:"varint,4,opt,name=IsValidator,proto3" json:"IsValidator,omitempty"`
	NumValidators        int64    `protobuf:"varint,5,opt,name=NumValidators,proto3" json:"NumValidators,omitempty"`
	NumPeers             int64    `protobuf:"varint,6,opt,name=NumPeers,proto3" json:"NumPeers,omitempty"`
	RunningTime          int64    `protobuf:"varint,7,opt,name=RunningTime,proto3" json:"RunningTime,omitempty"`
	PubKey               string   `protobuf:"bytes,8,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultSurveillance) Reset()         { *m = ResultSurveillance{} }
func (m *ResultSurveillance) String() string { return proto.CompactTextString(m) }
func (*ResultSurveillance) ProtoMessage()    {}
func (*ResultSurveillance) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{21}
}
func (m *ResultSurveillance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultSurveillance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultSurveillance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultSurveillance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultSurveillance.Merge(m, src)
}
func (m *ResultSurveillance) XXX_Size() int {
	return m.Size()
}
func (m *ResultSurveillance) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultSurveillance.DiscardUnknown(m)
}

var xxx_messageInfo_ResultSurveillance proto.InternalMessageInfo

func (m *ResultSurveillance) GetNanoSecsPerTx() int64 {
	if m != nil {
		return m.NanoSecsPerTx
	}
	return 0
}

func (m *ResultSurveillance) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ResultSurveillance) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *ResultSurveillance) GetIsValidator() bool {
	if m != nil {
		return m.IsValidator
	}
	return false
}

func (m *ResultSurveillance) GetNumValidators() int64 {
	if m != nil {
		return m.NumValidators
	}
	return 0
}

func (m *ResultSurveillance) GetNumPeers() int64 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *ResultSurveillance) GetRunningTime() int64 {
	if m != nil {
		return m.RunningTime
	}
	return 0
}

func (m *ResultSurveillance) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

type ResultCoreVersion struct {
	Version              string   `protobuf:"bytes,1,opt,name=Version,proto3" json:"Version,omitempty"`
	AppName              string   `protobuf:"bytes,2,opt,name=AppName,proto3" json:"AppName,omitempty"`
	AppVersion           string   `protobuf:"bytes,3,opt,name=AppVersion,proto3" json:"AppVersion,omitempty"`
	Hash                 string   `protobuf:"bytes,4,opt,name=Hash,proto3" json:"Hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultCoreVersion) Reset()         { *m = ResultCoreVersion{} }
func (m *ResultCoreVersion) String() string { return proto.CompactTextString(m) }
func (*ResultCoreVersion) ProtoMessage()    {}
func (*ResultCoreVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{22}
}
func (m *ResultCoreVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultCoreVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultCoreVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultCoreVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultCoreVersion.Merge(m, src)
}
func (m *ResultCoreVersion) XXX_Size() int {
	return m.Size()
}
func (m *ResultCoreVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultCoreVersion.DiscardUnknown(m)
}

var xxx_messageInfo_ResultCoreVersion proto.InternalMessageInfo

func (m *ResultCoreVersion) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ResultCoreVersion) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *ResultCoreVersion) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *ResultCoreVersion) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type ResultNonEmptyHeights struct {
	Heights              []int64  `protobuf:"varint,1,rep,packed,name=Heights,proto3" json:"Heights,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultNonEmptyHeights) Reset()         { *m = ResultNonEmptyHeights{} }
func (m *ResultNonEmptyHeights) String() string { return proto.CompactTextString(m) }
func (*ResultNonEmptyHeights) ProtoMessage()    {}
func (*ResultNonEmptyHeights) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{23}
}
func (m *ResultNonEmptyHeights) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultNonEmptyHeights) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultNonEmptyHeights.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultNonEmptyHeights) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultNonEmptyHeights.Merge(m, src)
}
func (m *ResultNonEmptyHeights) XXX_Size() int {
	return m.Size()
}
func (m *ResultNonEmptyHeights) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultNonEmptyHeights.DiscardUnknown(m)
}

var xxx_messageInfo_ResultNonEmptyHeights proto.InternalMessageInfo

func (m *ResultNonEmptyHeights) GetHeights() []int64 {
	if m != nil {
		return m.Heights
	}
	return nil
}

type ResultHealthInfo struct {
	Status               int32    `protobuf:"varint,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultHealthInfo) Reset()         { *m = ResultHealthInfo{} }
func (m *ResultHealthInfo) String() string { return proto.CompactTextString(m) }
func (*ResultHealthInfo) ProtoMessage()    {}
func (*ResultHealthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{24}
}
func (m *ResultHealthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultHealthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultHealthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultHealthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultHealthInfo.Merge(m, src)
}
func (m *ResultHealthInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResultHealthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultHealthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResultHealthInfo proto.InternalMessageInfo

func (m *ResultHealthInfo) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ResultLastHeight struct {
	LastHeight           int64    `protobuf:"varint,1,opt,name=LastHeight,proto3" json:"LastHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultLastHeight) Reset()         { *m = ResultLastHeight{} }
func (m *ResultLastHeight) String() string { return proto.CompactTextString(m) }
func (*ResultLastHeight) ProtoMessage()    {}
func (*ResultLastHeight) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{25}
}
func (m *ResultLastHeight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultLastHeight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultLastHeight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultLastHeight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultLastHeight.Merge(m, src)
}
func (m *ResultLastHeight) XXX_Size() int {
	return m.Size()
}
func (m *ResultLastHeight) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultLastHeight.DiscardUnknown(m)
}

var xxx_messageInfo_ResultLastHeight proto.InternalMessageInfo

func (m *ResultLastHeight) GetLastHeight() int64 {
	if m != nil {
		return m.LastHeight
	}
	return 0
}

type ResultShards struct {
	Names                []string `protobuf:"bytes,1,rep,name=Names,proto3" json:"Names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultShards) Reset()         { *m = ResultShards{} }
func (m *ResultShards) String() string { return proto.CompactTextString(m) }
func (*ResultShards) ProtoMessage()    {}
func (*ResultShards) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{26}
}
func (m *ResultShards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultShards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultShards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultShards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultShards.Merge(m, src)
}
func (m *ResultShards) XXX_Size() int {
	return m.Size()
}
func (m *ResultShards) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultShards.DiscardUnknown(m)
}

var xxx_messageInfo_ResultShards proto.InternalMessageInfo

func (m *ResultShards) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type ResultDialSeeds struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultDialSeeds) Reset()         { *m = ResultDialSeeds{} }
func (m *ResultDialSeeds) String() string { return proto.CompactTextString(m) }
func (*ResultDialSeeds) ProtoMessage()    {}
func (*ResultDialSeeds) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{27}
}
func (m *ResultDialSeeds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultDialSeeds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultDialSeeds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultDialSeeds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultDialSeeds.Merge(m, src)
}
func (m *ResultDialSeeds) XXX_Size() int {
	return m.Size()
}
func (m *ResultDialSeeds) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultDialSeeds.DiscardUnknown(m)
}

var xxx_messageInfo_ResultDialSeeds proto.InternalMessageInfo

type ResultValidator struct {
	Address              []byte   `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	PubKey               string   `protobuf:"bytes,2,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	VotingPower          int64    `protobuf:"varint,3,opt,name=VotingPower,proto3" json:"VotingPower,omitempty"`
	Accum                int64    `protobuf:"varint,4,opt,name=Accum,proto3" json:"Accum,omitempty"`
	IsCA                 bool     `protobuf:"varint,5,opt,name=IsCA,proto3" json:"IsCA,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultValidator) Reset()         { *m = ResultValidator{} }
func (m *ResultValidator) String() string { return proto.CompactTextString(m) }
func (*ResultValidator) ProtoMessage()    {}
func (*ResultValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{28}
}
func (m *ResultValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultValidator.Merge(m, src)
}
func (m *ResultValidator) XXX_Size() int {
	return m.Size()
}
func (m *ResultValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultValidator.DiscardUnknown(m)
}

var xxx_messageInfo_ResultValidator proto.InternalMessageInfo

func (m *ResultValidator) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *ResultValidator) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *ResultValidator) GetVotingPower() int64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

func (m *ResultValidator) GetAccum() int64 {
	if m != nil {
		return m.Accum
	}
	return 0
}

func (m *ResultValidator) GetIsCA() bool {
	if m != nil {
		return m.IsCA
	}
	return false
}

type ResultTransaction struct {
	BlockHash            []byte   `protobuf:"bytes,1,opt,name=BlockHash,proto3" json:"BlockHash,omitempty"`
	BlockHeight          uint64   `protobuf:"varint,2,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	TransactionIndex     uint64   `protobuf:"varint,3,opt,name=TransactionIndex,proto3" json:"TransactionIndex,omitempty"`
	RawTransaction       []byte   `protobuf:"bytes,4,opt,name=RawTransaction,proto3" json:"RawTransaction,omitempty"`
	Timestamp            uint64   `protobuf:"varint,5,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultTransaction) Reset()         { *m = ResultTransaction{} }
func (m *ResultTransaction) String() string { return proto.CompactTextString(m) }
func (*ResultTransaction) ProtoMessage()    {}
func (*ResultTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{29}
}
func (m *ResultTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultTransaction.Merge(m, src)
}
func (m *ResultTransaction) XXX_Size() int {
	return m.Size()
}
func (m *ResultTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_ResultTransaction proto.InternalMessageInfo

func (m *ResultTransaction) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *ResultTransaction) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ResultTransaction) GetTransactionIndex() uint64 {
	if m != nil {
		return m.TransactionIndex
	}
	return 0
}

func (m *ResultTransaction) GetRawTransaction() []byte {
	if m != nil {
		return m.RawTransaction
	}
	return nil
}

func (m *ResultTransaction) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type ResultNumArchivedBlocks struct {
	Num                  int64    `protobuf:"varint,1,opt,name=Num,proto3" json:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultNumArchivedBlocks) Reset()         { *m = ResultNumArchivedBlocks{} }
func (m *ResultNumArchivedBlocks) String() string { return proto.CompactTextString(m) }
func (*ResultNumArchivedBlocks) ProtoMessage()    {}
func (*ResultNumArchivedBlocks) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{30}
}
func (m *ResultNumArchivedBlocks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultNumArchivedBlocks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultNumArchivedBlocks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultNumArchivedBlocks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultNumArchivedBlocks.Merge(m, src)
}
func (m *ResultNumArchivedBlocks) XXX_Size() int {
	return m.Size()
}
func (m *ResultNumArchivedBlocks) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultNumArchivedBlocks.DiscardUnknown(m)
}

var xxx_messageInfo_ResultNumArchivedBlocks proto.InternalMessageInfo

func (m *ResultNumArchivedBlocks) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

type ResultNumLimitTx struct {
	Num                  uint64   `protobuf:"varint,1,opt,name=Num,proto3" json:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultNumLimitTx) Reset()         { *m = ResultNumLimitTx{} }
func (m *ResultNumLimitTx) String() string { return proto.CompactTextString(m) }
func (*ResultNumLimitTx) ProtoMessage()    {}
func (*ResultNumLimitTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{31}
}
func (m *ResultNumLimitTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultNumLimitTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultNumLimitTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultNumLimitTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultNumLimitTx.Merge(m, src)
}
func (m *ResultNumLimitTx) XXX_Size() int {
	return m.Size()
}
func (m *ResultNumLimitTx) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultNumLimitTx.DiscardUnknown(m)
}

var xxx_messageInfo_ResultNumLimitTx proto.InternalMessageInfo

func (m *ResultNumLimitTx) GetNum() uint64 {
	if m != nil {
		return m.Num
	}
	return 0
}

type ResultSubscribe struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultSubscribe) Reset()         { *m = ResultSubscribe{} }
func (m *ResultSubscribe) String() string { return proto.CompactTextString(m) }
func (*ResultSubscribe) ProtoMessage()    {}
func (*ResultSubscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_1668729afd8eb0ca, []int{32}
}
func (m *ResultSubscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultSubscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultSubscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultSubscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultSubscribe.Merge(m, src)
}
func (m *ResultSubscribe) XXX_Size() int {
	return m.Size()
}
func (m *ResultSubscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultSubscribe.DiscardUnknown(m)
}

var xxx_messageInfo_ResultSubscribe proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("rpc.Type", Type_name, Type_value)
	proto.RegisterType((*ResultBlockchainInfo)(nil), "rpc.ResultBlockchainInfo")
	proto.RegisterType((*ResultGenesis)(nil), "rpc.ResultGenesis")
	proto.RegisterType((*ResultBlock)(nil), "rpc.ResultBlock")
	proto.RegisterType((*ResultOrgs)(nil), "rpc.ResultOrgs")
	proto.RegisterType((*ResultStatus)(nil), "rpc.ResultStatus")
	proto.RegisterType((*Peer)(nil), "rpc.Peer")
	proto.RegisterType((*ResultNetInfo)(nil), "rpc.ResultNetInfo")
	proto.RegisterType((*ResultValidators)(nil), "rpc.ResultValidators")
	proto.RegisterType((*ResultDumpConsensusState)(nil), "rpc.ResultDumpConsensusState")
	proto.RegisterType((*ResultBroadcastTx)(nil), "rpc.ResultBroadcastTx")
	proto.RegisterType((*ResultRequestAdminOP)(nil), "rpc.ResultRequestAdminOP")
	proto.RegisterType((*ResultBroadcastTxCommit)(nil), "rpc.ResultBroadcastTxCommit")
	proto.RegisterType((*ResultUnconfirmedTxs)(nil), "rpc.ResultUnconfirmedTxs")
	proto.RegisterType((*ResultInfo)(nil), "rpc.ResultInfo")
	proto.RegisterType((*ResultQuery)(nil), "rpc.ResultQuery")
	proto.RegisterType((*ResultRefuseList)(nil), "rpc.ResultRefuseList")
	proto.RegisterType((*ResultUnsafeFlushMempool)(nil), "rpc.ResultUnsafeFlushMempool")
	proto.RegisterType((*ResultUnsafeSetConfig)(nil), "rpc.ResultUnsafeSetConfig")
	proto.RegisterType((*ResultUnsafeProfile)(nil), "rpc.ResultUnsafeProfile")
	proto.RegisterType((*ResultUnsubscribe)(nil), "rpc.ResultUnsubscribe")
	proto.RegisterType((*ResultEvent)(nil), "rpc.ResultEvent")
	proto.RegisterType((*ResultSurveillance)(nil), "rpc.ResultSurveillance")
	proto.RegisterType((*ResultCoreVersion)(nil), "rpc.ResultCoreVersion")
	proto.RegisterType((*ResultNonEmptyHeights)(nil), "rpc.ResultNonEmptyHeights")
	proto.RegisterType((*ResultHealthInfo)(nil), "rpc.ResultHealthInfo")
	proto.RegisterType((*ResultLastHeight)(nil), "rpc.ResultLastHeight")
	proto.RegisterType((*ResultShards)(nil), "rpc.ResultShards")
	proto.RegisterType((*ResultDialSeeds)(nil), "rpc.ResultDialSeeds")
	proto.RegisterType((*ResultValidator)(nil), "rpc.ResultValidator")
	proto.RegisterType((*ResultTransaction)(nil), "rpc.ResultTransaction")
	proto.RegisterType((*ResultNumArchivedBlocks)(nil), "rpc.ResultNumArchivedBlocks")
	proto.RegisterType((*ResultNumLimitTx)(nil), "rpc.ResultNumLimitTx")
	proto.RegisterType((*ResultSubscribe)(nil), "rpc.ResultSubscribe")
}

func init() { proto.RegisterFile("gemmill/protos/rpc/rpc.proto", fileDescriptor_1668729afd8eb0ca) }

var fileDescriptor_1668729afd8eb0ca = []byte{
	// 1572 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xef, 0xc6, 0x4e, 0x62, 0xbf, 0x38, 0xc9, 0x78, 0x92, 0x34, 0x6e, 0xd4, 0x6f, 0xbe, 0x61,
	0xfa, 0x43, 0x21, 0x45, 0x0e, 0x0d, 0x15, 0x27, 0x0e, 0xb8, 0x6e, 0x21, 0x11, 0xa9, 0x63, 0x26,
	0x4e, 0x91, 0x38, 0x20, 0x36, 0xbb, 0x13, 0x7b, 0xc1, 0xbb, 0x3b, 0xdd, 0xd9, 0x4d, 0x13, 0xc1,
	0x01, 0x10, 0x17, 0x4e, 0xf4, 0xc0, 0x81, 0x23, 0xbf, 0xee, 0xfc, 0x15, 0x48, 0x9c, 0x10, 0x7f,
	0x02, 0x2a, 0xff, 0x08, 0x9a, 0x5f, 0xde, 0xb5, 0xad, 0x0a, 0xc1, 0x81, 0x83, 0xed, 0x79, 0x9f,
	0xf7, 0x66, 0xde, 0x9b, 0xf7, 0x73, 0x0c, 0xd7, 0xfb, 0x2c, 0x0c, 0x83, 0xe1, 0x70, 0x97, 0x27,
	0x71, 0x1a, 0x8b, 0xdd, 0x84, 0x7b, 0xf2, 0xd3, 0x54, 0x24, 0x2e, 0x25, 0xdc, 0xdb, 0xd8, 0x9a,
	0x10, 0x49, 0x2f, 0x39, 0x33, 0xdf, 0x5a, 0x6c, 0x83, 0x4c, 0x48, 0xb0, 0x73, 0x16, 0xa5, 0xf6,
	0xc7, 0xc8, 0x4c, 0x2a, 0xe2, 0x7b, 0x5c, 0x7e, 0x5e, 0x70, 0x82, 0x97, 0x5c, 0xf2, 0x34, 0x36,
	0x3f, 0x5a, 0x86, 0x0c, 0x60, 0x95, 0x32, 0x91, 0x0d, 0xd3, 0xfb, 0xc3, 0xd8, 0xfb, 0xd8, 0x1b,
	0xb8, 0x41, 0x74, 0x10, 0x9d, 0xc5, 0x78, 0x13, 0xe0, 0xd0, 0x15, 0xe9, 0x3e, 0x0b, 0xfa, 0x83,
	0xb4, 0xe1, 0x6c, 0x39, 0xdb, 0x25, 0x5a, 0x40, 0xf0, 0xab, 0x00, 0x6a, 0xc7, 0x23, 0x96, 0xba,
	0xa2, 0x31, 0xb3, 0x55, 0xda, 0x5e, 0xd8, 0x43, 0x4d, 0x6d, 0xff, 0x88, 0x41, 0x0b, 0x32, 0xe4,
	0x0d, 0x58, 0xd4, 0x9a, 0xde, 0x66, 0x11, 0x13, 0x81, 0xc0, 0x77, 0x60, 0xde, 0x2c, 0xd5, 0xf9,
	0x0b, 0x7b, 0x75, 0xb3, 0xdf, 0xa0, 0x0f, 0x62, 0x8f, 0x5a, 0x09, 0xe2, 0xc2, 0x42, 0xc1, 0x4e,
	0xdc, 0x84, 0xea, 0xe8, 0x68, 0xb3, 0x7b, 0x5a, 0x7b, 0x2e, 0x82, 0x09, 0xcc, 0x2a, 0xa2, 0x31,
	0xa3, 0x64, 0x6b, 0x45, 0x59, 0xaa, 0x59, 0x84, 0x00, 0x68, 0x15, 0x47, 0x49, 0x5f, 0xe0, 0x55,
	0x98, 0xed, 0xb8, 0x21, 0x93, 0xb6, 0x95, 0xb6, 0xab, 0x54, 0x13, 0xe4, 0xab, 0x19, 0xa8, 0x69,
	0xa1, 0xe3, 0xd4, 0x4d, 0x33, 0x81, 0x5f, 0x86, 0x4a, 0x27, 0xf6, 0x99, 0xf4, 0x99, 0xb1, 0x63,
	0xb1, 0x29, 0x23, 0x60, 0x41, 0x3a, 0x62, 0xe3, 0xdb, 0x30, 0xd7, 0xcd, 0x4e, 0xdf, 0x61, 0x97,
	0xc6, 0x88, 0xa5, 0xa6, 0x89, 0x84, 0x46, 0xa9, 0xe1, 0xe2, 0x6d, 0x58, 0x3e, 0x74, 0x53, 0x26,
	0xf4, 0x55, 0xf7, 0x5d, 0x31, 0x68, 0x94, 0xb6, 0x9c, 0xed, 0x1a, 0x9d, 0x84, 0xf1, 0x4d, 0x58,
	0xd4, 0x50, 0x8b, 0x73, 0x25, 0x57, 0x56, 0x72, 0xe3, 0x20, 0x7e, 0x05, 0xea, 0xc5, 0x8d, 0x3a,
	0xa2, 0xb3, 0x2a, 0xa2, 0xd3, 0x8c, 0x09, 0xed, 0xbd, 0x20, 0x64, 0x8d, 0x39, 0x25, 0x3b, 0x09,
	0x93, 0x6f, 0x1c, 0x28, 0x77, 0x19, 0x4b, 0xfe, 0x89, 0x0f, 0x36, 0x01, 0x0e, 0xc4, 0x51, 0x96,
	0x9e, 0xc6, 0x59, 0xe4, 0x2b, 0x3f, 0x54, 0x68, 0x01, 0xc1, 0x2d, 0x40, 0xed, 0x38, 0x8a, 0x98,
	0x97, 0x06, 0x71, 0xa4, 0x5d, 0xac, 0x2e, 0xbf, 0xb0, 0xb7, 0xa6, 0x8e, 0x9c, 0x64, 0xd2, 0x29,
	0x71, 0x32, 0xb4, 0x79, 0xd6, 0x61, 0xa9, 0xd2, 0x79, 0x1d, 0xaa, 0x87, 0x81, 0x48, 0x59, 0x14,
	0x44, 0x7d, 0x65, 0x5f, 0x85, 0xe6, 0x40, 0xce, 0x65, 0x89, 0xce, 0xe3, 0x2a, 0xcd, 0x01, 0xfc,
	0x7f, 0x98, 0xe5, 0x4c, 0x72, 0x4a, 0x2a, 0xc3, 0xab, 0x4d, 0x59, 0xc6, 0xf2, 0xd2, 0x54, 0xe3,
	0xe4, 0x23, 0x40, 0x5a, 0xdb, 0x63, 0x77, 0x18, 0xf8, 0x6e, 0x1a, 0x27, 0x02, 0x6f, 0xc1, 0x42,
	0xd1, 0xd5, 0xba, 0x78, 0x8a, 0x10, 0xbe, 0x07, 0x90, 0xcb, 0x9b, 0xea, 0x59, 0x55, 0x67, 0x4f,
	0x1c, 0x46, 0x0b, 0x72, 0xc4, 0x87, 0x86, 0x66, 0x3f, 0xc8, 0x42, 0xde, 0x8e, 0x23, 0xc1, 0x22,
	0x91, 0x09, 0x79, 0x6d, 0x26, 0x1d, 0x4b, 0xa5, 0x07, 0x15, 0xa5, 0x54, 0x56, 0x69, 0x01, 0x91,
	0x61, 0x55, 0x66, 0x8f, 0x10, 0x7b, 0xd9, 0x49, 0x98, 0x9c, 0x43, 0xdd, 0x54, 0x5a, 0x12, 0xbb,
	0xbe, 0xe7, 0x8a, 0xb4, 0x77, 0x81, 0x6f, 0x40, 0xb9, 0x1d, 0xfb, 0xfa, 0xe0, 0xa5, 0xbd, 0x65,
	0x53, 0x3e, 0x12, 0xea, 0x5d, 0x72, 0x46, 0x15, 0x13, 0x63, 0x28, 0x3f, 0x70, 0x53, 0x57, 0x85,
	0xb5, 0x46, 0xd5, 0x1a, 0x5f, 0x85, 0xb9, 0xde, 0xc5, 0x28, 0x87, 0xab, 0xd4, 0x50, 0x18, 0x41,
	0xe9, 0x30, 0xee, 0xab, 0x84, 0xad, 0x52, 0xb9, 0x24, 0xae, 0xed, 0x44, 0x94, 0x3d, 0xc9, 0x64,
	0xfa, 0xfa, 0x61, 0x10, 0x1d, 0x75, 0xff, 0xbd, 0x6a, 0xa3, 0xa2, 0x94, 0xab, 0xf8, 0x14, 0xd6,
	0xa7, 0xae, 0xd6, 0x8e, 0xc3, 0x30, 0x48, 0xff, 0x8b, 0x0b, 0xbe, 0x6e, 0x2f, 0x78, 0x12, 0x79,
	0x71, 0x74, 0x16, 0x24, 0x21, 0xf3, 0x7b, 0x17, 0x02, 0xd7, 0xc0, 0xe9, 0x98, 0x24, 0x71, 0x3a,
	0x72, 0x5f, 0xef, 0x42, 0x07, 0xa7, 0x46, 0xe5, 0x92, 0x3c, 0x73, 0x6c, 0x63, 0x52, 0xe9, 0x6c,
	0x8d, 0xd0, 0x31, 0xd6, 0x46, 0x34, 0x60, 0xfe, 0x31, 0x4b, 0x44, 0x10, 0x47, 0xca, 0xb6, 0x2a,
	0xb5, 0xa4, 0x2e, 0xe7, 0xf1, 0xd2, 0x2f, 0xd9, 0x72, 0x1e, 0x2f, 0xfc, 0x1d, 0x40, 0x23, 0x68,
	0xbc, 0x9f, 0x4c, 0xe1, 0xe4, 0x9e, 0xed, 0xc6, 0xef, 0x66, 0x2c, 0xb9, 0xc4, 0xb7, 0x60, 0x4e,
	0x93, 0xa3, 0xf2, 0xd7, 0xee, 0x33, 0xf1, 0x34, 0x4c, 0xb2, 0x63, 0x6b, 0x85, 0xb2, 0xb3, 0x4c,
	0x30, 0x59, 0x65, 0xd2, 0x7d, 0xa3, 0xad, 0x32, 0x1d, 0xad, 0xec, 0x86, 0xcd, 0xf5, 0x93, 0x48,
	0xb8, 0x67, 0xec, 0xad, 0x61, 0x26, 0x06, 0x8f, 0x58, 0xc8, 0xe3, 0x78, 0x48, 0xd6, 0x61, 0xad,
	0xc8, 0x3b, 0x66, 0x69, 0x5b, 0xfa, 0xb3, 0x4f, 0xd6, 0x60, 0xa5, 0xc8, 0xe8, 0x26, 0xf1, 0x59,
	0x30, 0x64, 0x64, 0xc5, 0x66, 0xf4, 0x49, 0x24, 0xb2, 0x53, 0xe1, 0x25, 0xc1, 0x29, 0x23, 0x1f,
	0xd8, 0x2b, 0x3c, 0x94, 0x03, 0x55, 0x7a, 0x55, 0x76, 0x78, 0xeb, 0x55, 0xb9, 0xc6, 0xb7, 0xa0,
	0x2c, 0x83, 0xaf, 0x5c, 0xba, 0xb4, 0x57, 0x6f, 0x9a, 0xd1, 0xab, 0x36, 0xe8, 0xac, 0x90, 0xdf,
	0x72, 0x52, 0x28, 0xc8, 0x74, 0x69, 0x4d, 0x90, 0x2f, 0x67, 0x00, 0x9b, 0x49, 0x91, 0x25, 0xe7,
	0x2c, 0x18, 0x0e, 0xdd, 0xc8, 0x63, 0xb2, 0x65, 0x77, 0xdc, 0x28, 0x3e, 0x66, 0x9e, 0xe8, 0xb2,
	0xa4, 0x77, 0x61, 0x02, 0x3f, 0x0e, 0x4a, 0xaf, 0x98, 0x60, 0xcd, 0x28, 0xb6, 0xa1, 0xa4, 0x95,
	0x2d, 0xdf, 0x4f, 0x4c, 0xaa, 0xa9, 0xb5, 0xec, 0x36, 0x07, 0x62, 0xd4, 0x25, 0x54, 0xc8, 0x2a,
	0xb4, 0x08, 0x29, 0x9d, 0x59, 0x58, 0x68, 0x38, 0xb3, 0x46, 0x67, 0x11, 0xc4, 0x1b, 0x50, 0xe9,
	0x64, 0x61, 0x57, 0x75, 0x3b, 0xdd, 0xf1, 0x47, 0xb4, 0xd4, 0x41, 0xb3, 0x48, 0xf6, 0x4b, 0x35,
	0x10, 0xe6, 0x75, 0x47, 0x2b, 0x40, 0xd2, 0x62, 0x33, 0xdc, 0x2a, 0xba, 0x0c, 0x34, 0x45, 0x3e,
	0xb1, 0xbe, 0x6f, 0xc7, 0x09, 0xb3, 0x49, 0x59, 0x48, 0x57, 0x67, 0x3c, 0x5d, 0x1b, 0x30, 0xdf,
	0xe2, 0x5c, 0x45, 0xc2, 0x24, 0xb2, 0x21, 0x65, 0x83, 0x6b, 0x71, 0x6e, 0xb7, 0x69, 0x07, 0x14,
	0x10, 0xe9, 0x9a, 0x51, 0xca, 0x56, 0xa9, 0x5a, 0x93, 0xbb, 0x36, 0x51, 0x3a, 0x71, 0xf4, 0x30,
	0xe4, 0xe9, 0xa5, 0x76, 0xa3, 0x90, 0x6a, 0xcc, 0x52, 0xa5, 0x5d, 0x89, 0x5a, 0x32, 0xcf, 0xd1,
	0x7d, 0xe6, 0x0e, 0xd3, 0x81, 0xaa, 0xb8, 0xab, 0x30, 0x67, 0x46, 0x91, 0xb4, 0x76, 0x96, 0x1a,
	0x8a, 0xec, 0x59, 0xd9, 0xc2, 0xbb, 0xe8, 0x6f, 0xde, 0x4d, 0xe4, 0xe6, 0xe8, 0xfd, 0x30, 0x70,
	0x13, 0xff, 0x45, 0xcf, 0x8c, 0x3a, 0x2c, 0x9b, 0x4e, 0x1f, 0xb8, 0xc3, 0x63, 0xc6, 0x7c, 0x41,
	0xbe, 0x76, 0x2c, 0x96, 0x07, 0x56, 0x7a, 0xcb, 0xf7, 0x13, 0x26, 0xb4, 0x65, 0x35, 0x6a, 0xc9,
	0x42, 0x38, 0x66, 0x8a, 0xe1, 0x90, 0x81, 0x7c, 0x1c, 0xa7, 0x41, 0xd4, 0xef, 0xc6, 0x4f, 0x59,
	0x62, 0x5a, 0x41, 0x11, 0x92, 0x06, 0xb5, 0x3c, 0x2f, 0x0b, 0x95, 0x23, 0x4b, 0x54, 0x13, 0xd2,
	0xbb, 0x07, 0xa2, 0xdd, 0x52, 0x99, 0x53, 0xa1, 0x6a, 0x4d, 0x7e, 0x71, 0x6c, 0x6c, 0x7b, 0x89,
	0x1b, 0x09, 0x57, 0x0d, 0x61, 0x39, 0x4f, 0xf3, 0x77, 0x8b, 0xb6, 0x2a, 0x07, 0x26, 0x47, 0xa3,
	0x34, 0xae, 0x3c, 0x3e, 0x1a, 0x77, 0x00, 0x15, 0x8e, 0x3b, 0x88, 0x7c, 0x76, 0xa1, 0xcc, 0x2c,
	0xd3, 0x29, 0x1c, 0xdf, 0x86, 0x25, 0xea, 0x3e, 0x2d, 0xc0, 0xa6, 0x61, 0x4d, 0xa0, 0xd2, 0x26,
	0x99, 0xa4, 0x22, 0x75, 0x43, 0xae, 0xae, 0x50, 0xa6, 0x39, 0x40, 0xee, 0xd8, 0xa9, 0xd0, 0xc9,
	0xc2, 0x56, 0xe2, 0x0d, 0x82, 0x73, 0xe6, 0x2b, 0x8b, 0x84, 0x6c, 0xc6, 0x9d, 0x2c, 0x34, 0x61,
	0x94, 0x4b, 0x72, 0xd3, 0xc6, 0xbc, 0x93, 0x85, 0x87, 0x41, 0x18, 0xc8, 0xe1, 0x58, 0x90, 0x2a,
	0x6b, 0xa9, 0x51, 0xfc, 0x8e, 0x6d, 0xbf, 0xd9, 0xf9, 0xad, 0xac, 0xbb, 0x09, 0x5e, 0x80, 0x79,
	0xca, 0xbd, 0x4e, 0x1c, 0x31, 0x74, 0x05, 0x2f, 0x01, 0x50, 0xee, 0x99, 0x47, 0x2e, 0x72, 0xf0,
	0x1a, 0xd4, 0x29, 0xf7, 0xc6, 0xdf, 0xe2, 0x68, 0x06, 0xd7, 0xa0, 0x62, 0x61, 0x54, 0xc2, 0x57,
	0x01, 0xeb, 0x13, 0x8a, 0x39, 0x8d, 0xca, 0x78, 0x11, 0xaa, 0x94, 0x7b, 0x3a, 0x39, 0xd1, 0x96,
	0x39, 0xdb, 0xbc, 0x82, 0xd0, 0x4b, 0x18, 0x41, 0x8d, 0x72, 0x6f, 0x94, 0x51, 0x88, 0x18, 0x53,
	0xe4, 0x73, 0x17, 0xdd, 0xc0, 0x75, 0x58, 0xa4, 0xdc, 0xcb, 0x5b, 0x33, 0x42, 0x06, 0xca, 0x7b,
	0x04, 0x7a, 0x13, 0x5f, 0x83, 0x35, 0x79, 0xc8, 0xd4, 0x03, 0x04, 0xb5, 0x30, 0x86, 0x25, 0x69,
	0x64, 0x3e, 0x5a, 0xd1, 0x87, 0xe6, 0x3e, 0xe3, 0x03, 0x0f, 0xc9, 0x79, 0xb5, 0x3a, 0x2e, 0xaa,
	0xa7, 0x30, 0x3a, 0xc5, 0xeb, 0xb0, 0xa2, 0xac, 0x50, 0x4f, 0x80, 0x63, 0xce, 0xbc, 0xc0, 0x1d,
	0x1e, 0x75, 0x91, 0x67, 0x5c, 0xa0, 0xe6, 0x0d, 0xe2, 0xc6, 0x72, 0x75, 0xb1, 0x27, 0xb8, 0xae,
	0x2e, 0x36, 0x72, 0x35, 0xfa, 0xcc, 0xc1, 0x2b, 0xca, 0x96, 0x42, 0xbf, 0x47, 0x9f, 0x3b, 0x78,
	0x51, 0x1d, 0xa1, 0xda, 0x33, 0xfa, 0xc2, 0xc1, 0xeb, 0xca, 0x8d, 0x13, 0x33, 0x04, 0x7d, 0xe7,
	0xe0, 0x4d, 0xb8, 0x96, 0x33, 0x52, 0x37, 0x49, 0xdb, 0xdd, 0x13, 0x33, 0x4b, 0x12, 0xf4, 0xbd,
	0x83, 0xff, 0x07, 0x8d, 0x02, 0x3f, 0xe6, 0x45, 0xf6, 0x0f, 0xe3, 0xdb, 0xdf, 0x4b, 0x82, 0x94,
	0xed, 0x33, 0x97, 0x1b, 0x01, 0xf4, 0xa3, 0x83, 0x37, 0x94, 0x0b, 0xa7, 0xe7, 0x1a, 0xfa, 0xc9,
	0xda, 0x5d, 0xe8, 0x95, 0xe8, 0x67, 0x07, 0xaf, 0xc2, 0xb2, 0xba, 0x5f, 0x3e, 0x46, 0xd0, 0x33,
	0xe7, 0x7e, 0xfb, 0xd7, 0xe7, 0x9b, 0xce, 0xef, 0xcf, 0x37, 0x9d, 0x3f, 0x9e, 0x6f, 0x3a, 0xdf,
	0xfe, 0xb9, 0x79, 0xe5, 0xfd, 0xbb, 0xfd, 0x20, 0x1d, 0x64, 0xa7, 0x4d, 0x2f, 0x0e, 0x77, 0x7d,
	0x97, 0xf3, 0x21, 0xf3, 0xfb, 0x2c, 0xd9, 0x6d, 0x45, 0x51, 0x5b, 0xe6, 0xd2, 0xee, 0xf4, 0xbf,
	0xd2, 0xd3, 0x39, 0xb5, 0x7e, 0xed, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd9, 0x0f, 0x1b, 0xb8,
	0xb2, 0x0e, 0x00, 0x00,
}

func (m *ResultBlockchainInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultBlockchainInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultBlockchainInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BlockMetas) > 0 {
		for iNdEx := len(m.BlockMetas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockMetas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.LastHeight != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.LastHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultGenesis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultGenesis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultGenesis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Genesis != nil {
		{
			size, err := m.Genesis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BlockMeta != nil {
		{
			size, err := m.BlockMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultOrgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultOrgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultOrgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResultStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LatestBlockTime != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.LatestBlockTime))
		i--
		dAtA[i] = 0x30
	}
	if m.LatestBlockHeight != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.LatestBlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.LatestAppHash) > 0 {
		i -= len(m.LatestAppHash)
		copy(dAtA[i:], m.LatestAppHash)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.LatestAppHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LatestBlockHash) > 0 {
		i -= len(m.LatestBlockHash)
		copy(dAtA[i:], m.LatestBlockHash)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.LatestBlockHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PubKey != nil {
		{
			size, err := m.PubKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NodeInfo != nil {
		{
			size, err := m.NodeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConnectionStatus != nil {
		{
			size, err := m.ConnectionStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IsOutbound {
		i--
		if m.IsOutbound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NodeInfo != nil {
		{
			size, err := m.NodeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultNetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultNetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultNetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Listeners) > 0 {
		for iNdEx := len(m.Listeners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Listeners[iNdEx])
			copy(dAtA[i:], m.Listeners[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.Listeners[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Listening {
		i--
		if m.Listening {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultValidators) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultValidators) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultValidators) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BlockHeight != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultDumpConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultDumpConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultDumpConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PeerRoundStates) > 0 {
		for iNdEx := len(m.PeerRoundStates) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PeerRoundStates[iNdEx])
			copy(dAtA[i:], m.PeerRoundStates[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.PeerRoundStates[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RoundState) > 0 {
		i -= len(m.RoundState)
		copy(dAtA[i:], m.RoundState)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.RoundState)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultBroadcastTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultBroadcastTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultBroadcastTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Log) > 0 {
		i -= len(m.Log)
		copy(dAtA[i:], m.Log)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Log)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultRequestAdminOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultRequestAdminOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultRequestAdminOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Log) > 0 {
		i -= len(m.Log)
		copy(dAtA[i:], m.Log)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Log)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultBroadcastTxCommit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultBroadcastTxCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultBroadcastTxCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Log) > 0 {
		i -= len(m.Log)
		copy(dAtA[i:], m.Log)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Log)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultUnconfirmedTxs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultUnconfirmedTxs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultUnconfirmedTxs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Txs) > 0 {
		for iNdEx := len(m.Txs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Txs[iNdEx])
			copy(dAtA[i:], m.Txs[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.Txs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.N != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastBlockAppHash) > 0 {
		i -= len(m.LastBlockAppHash)
		copy(dAtA[i:], m.LastBlockAppHash)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.LastBlockAppHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.LastBlockHeight != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.LastBlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultRefuseList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultRefuseList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultRefuseList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Result[iNdEx])
			copy(dAtA[i:], m.Result[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.Result[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResultUnsafeFlushMempool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultUnsafeFlushMempool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultUnsafeFlushMempool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResultUnsafeSetConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultUnsafeSetConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultUnsafeSetConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResultUnsafeProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultUnsafeProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultUnsafeProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResultUnsubscribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultUnsubscribe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultUnsubscribe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResultEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Event) > 0 {
		i -= len(m.Event)
		copy(dAtA[i:], m.Event)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Event)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultSurveillance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultSurveillance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultSurveillance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x42
	}
	if m.RunningTime != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.RunningTime))
		i--
		dAtA[i] = 0x38
	}
	if m.NumPeers != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.NumPeers))
		i--
		dAtA[i] = 0x30
	}
	if m.NumValidators != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.NumValidators))
		i--
		dAtA[i] = 0x28
	}
	if m.IsValidator {
		i--
		if m.IsValidator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.NanoSecsPerTx != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.NanoSecsPerTx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultCoreVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultCoreVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultCoreVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppVersion) > 0 {
		i -= len(m.AppVersion)
		copy(dAtA[i:], m.AppVersion)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.AppVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultNonEmptyHeights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultNonEmptyHeights) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultNonEmptyHeights) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Heights) > 0 {
		dAtA10 := make([]byte, len(m.Heights)*10)
		var j9 int
		for _, num1 := range m.Heights {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintRpc(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultHealthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultHealthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultHealthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultLastHeight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultLastHeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultLastHeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastHeight != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.LastHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultShards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultShards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultShards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResultDialSeeds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultDialSeeds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultDialSeeds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResultValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsCA {
		i--
		if m.IsCA {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Accum != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Accum))
		i--
		dAtA[i] = 0x20
	}
	if m.VotingPower != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RawTransaction) > 0 {
		i -= len(m.RawTransaction)
		copy(dAtA[i:], m.RawTransaction)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.RawTransaction)))
		i--
		dAtA[i] = 0x22
	}
	if m.TransactionIndex != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.TransactionIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockHeight != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultNumArchivedBlocks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultNumArchivedBlocks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultNumArchivedBlocks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultNumLimitTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultNumLimitTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultNumLimitTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultSubscribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultSubscribe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultSubscribe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintRpc(dAtA []byte, offset int, v uint64) int {
	offset -= sovRpc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ResultBlockchainInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastHeight != 0 {
		n += 1 + sovRpc(uint64(m.LastHeight))
	}
	if len(m.BlockMetas) > 0 {
		for _, e := range m.BlockMetas {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultGenesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Genesis != nil {
		l = m.Genesis.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockMeta != nil {
		l = m.BlockMeta.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultOrgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.PubKey != nil {
		l = m.PubKey.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.LatestBlockHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.LatestAppHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.LatestBlockHeight != 0 {
		n += 1 + sovRpc(uint64(m.LatestBlockHeight))
	}
	if m.LatestBlockTime != 0 {
		n += 1 + sovRpc(uint64(m.LatestBlockTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.IsOutbound {
		n += 2
	}
	if m.ConnectionStatus != nil {
		l = m.ConnectionStatus.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultNetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Listening {
		n += 2
	}
	if len(m.Listeners) > 0 {
		for _, s := range m.Listeners {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultValidators) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovRpc(uint64(m.BlockHeight))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultDumpConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoundState)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.PeerRoundStates) > 0 {
		for _, s := range m.PeerRoundStates {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultBroadcastTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRpc(uint64(m.Code))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultRequestAdminOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRpc(uint64(m.Code))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultBroadcastTxCommit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRpc(uint64(m.Code))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultUnconfirmedTxs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.N != 0 {
		n += 1 + sovRpc(uint64(m.N))
	}
	if len(m.Txs) > 0 {
		for _, b := range m.Txs {
			l = len(b)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.LastBlockHeight != 0 {
		n += 1 + sovRpc(uint64(m.LastBlockHeight))
	}
	l = len(m.LastBlockAppHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultRefuseList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, s := range m.Result {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultUnsafeFlushMempool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultUnsafeSetConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultUnsafeProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultUnsubscribe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovRpc(uint64(m.Type))
	}
	l = len(m.Event)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultSurveillance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NanoSecsPerTx != 0 {
		n += 1 + sovRpc(uint64(m.NanoSecsPerTx))
	}
	if m.Height != 0 {
		n += 1 + sovRpc(uint64(m.Height))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.IsValidator {
		n += 2
	}
	if m.NumValidators != 0 {
		n += 1 + sovRpc(uint64(m.NumValidators))
	}
	if m.NumPeers != 0 {
		n += 1 + sovRpc(uint64(m.NumPeers))
	}
	if m.RunningTime != 0 {
		n += 1 + sovRpc(uint64(m.RunningTime))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultCoreVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultNonEmptyHeights) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Heights) > 0 {
		l = 0
		for _, e := range m.Heights {
			l += sovRpc(uint64(e))
		}
		n += 1 + sovRpc(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultHealthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRpc(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultLastHeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastHeight != 0 {
		n += 1 + sovRpc(uint64(m.LastHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultShards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultDialSeeds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.VotingPower != 0 {
		n += 1 + sovRpc(uint64(m.VotingPower))
	}
	if m.Accum != 0 {
		n += 1 + sovRpc(uint64(m.Accum))
	}
	if m.IsCA {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovRpc(uint64(m.BlockHeight))
	}
	if m.TransactionIndex != 0 {
		n += 1 + sovRpc(uint64(m.TransactionIndex))
	}
	l = len(m.RawTransaction)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRpc(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultNumArchivedBlocks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovRpc(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultNumLimitTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovRpc(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultSubscribe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRpc(x uint64) (n int) {
	return sovRpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResultBlockchainInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultBlockchainInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultBlockchainInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockMetas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockMetas = append(m.BlockMetas, &types.BlockMeta{})
			if err := m.BlockMetas[len(m.BlockMetas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultGenesis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultGenesis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultGenesis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Genesis == nil {
				m.Genesis = &types.GenesisDoc{}
			}
			if err := m.Genesis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockMeta == nil {
				m.BlockMeta = &types.BlockMeta{}
			}
			if err := m.BlockMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &types.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultOrgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultOrgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultOrgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeInfo == nil {
				m.NodeInfo = &p2p.NodeInfo{}
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubKey == nil {
				m.PubKey = &crypto.PubKey{}
			}
			if err := m.PubKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestBlockHash = append(m.LatestBlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LatestBlockHash == nil {
				m.LatestBlockHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestAppHash = append(m.LatestAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LatestAppHash == nil {
				m.LatestAppHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockHeight", wireType)
			}
			m.LatestBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockTime", wireType)
			}
			m.LatestBlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeInfo == nil {
				m.NodeInfo = &p2p.NodeInfo{}
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOutbound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOutbound = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectionStatus == nil {
				m.ConnectionStatus = &p2p.ConnectionStatus{}
			}
			if err := m.ConnectionStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultNetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultNetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultNetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listening", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Listening = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listeners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Listeners = append(m.Listeners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultValidators) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultValidators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultValidators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &ResultValidator{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultDumpConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultDumpConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultDumpConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoundState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRoundStates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerRoundStates = append(m.PeerRoundStates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultBroadcastTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultBroadcastTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultBroadcastTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= types.CodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultRequestAdminOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultRequestAdminOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultRequestAdminOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= types.CodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultBroadcastTxCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultBroadcastTxCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultBroadcastTxCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= types.CodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultUnconfirmedTxs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultUnconfirmedTxs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultUnconfirmedTxs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, make([]byte, postIndex-iNdEx))
			copy(m.Txs[len(m.Txs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockHeight", wireType)
			}
			m.LastBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastBlockAppHash = append(m.LastBlockAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LastBlockAppHash == nil {
				m.LastBlockAppHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &types.Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultRefuseList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultRefuseList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultRefuseList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultUnsafeFlushMempool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultUnsafeFlushMempool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultUnsafeFlushMempool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultUnsafeSetConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultUnsafeSetConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultUnsafeSetConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultUnsafeProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultUnsafeProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultUnsafeProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultUnsubscribe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultUnsubscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultUnsubscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= events.EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = append(m.Event[:0], dAtA[iNdEx:postIndex]...)
			if m.Event == nil {
				m.Event = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultSurveillance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultSurveillance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultSurveillance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NanoSecsPerTx", wireType)
			}
			m.NanoSecsPerTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NanoSecsPerTx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValidator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValidator = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumValidators", wireType)
			}
			m.NumValidators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumValidators |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPeers", wireType)
			}
			m.NumPeers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPeers |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningTime", wireType)
			}
			m.RunningTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunningTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultCoreVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultCoreVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultCoreVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultNonEmptyHeights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultNonEmptyHeights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultNonEmptyHeights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Heights = append(m.Heights, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Heights) == 0 {
					m.Heights = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Heights = append(m.Heights, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Heights", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultHealthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultHealthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultHealthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultLastHeight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultLastHeight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultLastHeight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultShards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultShards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultShards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultDialSeeds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultDialSeeds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultDialSeeds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accum", wireType)
			}
			m.Accum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCA", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCA = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHash == nil {
				m.BlockHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			m.TransactionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawTransaction", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawTransaction = append(m.RawTransaction[:0], dAtA[iNdEx:postIndex]...)
			if m.RawTransaction == nil {
				m.RawTransaction = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultNumArchivedBlocks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultNumArchivedBlocks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultNumArchivedBlocks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultNumLimitTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultNumLimitTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultNumLimitTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultSubscribe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultSubscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultSubscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRpc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRpc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRpc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRpc = fmt.Errorf("proto: unexpected end of group")
)
